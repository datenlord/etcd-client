// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct ResponseHeader {
    // message fields
    pub cluster_id: u64,
    pub member_id: u64,
    pub revision: i64,
    pub raft_term: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseHeader {
    fn default() -> &'a ResponseHeader {
        <ResponseHeader as ::protobuf::Message>::default_instance()
    }
}

impl ResponseHeader {
    pub fn new() -> ResponseHeader {
        ::std::default::Default::default()
    }

    // uint64 cluster_id = 1;


    pub fn get_cluster_id(&self) -> u64 {
        self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: u64) {
        self.cluster_id = v;
    }

    // uint64 member_id = 2;


    pub fn get_member_id(&self) -> u64 {
        self.member_id
    }
    pub fn clear_member_id(&mut self) {
        self.member_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_member_id(&mut self, v: u64) {
        self.member_id = v;
    }

    // int64 revision = 3;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }

    // uint64 raft_term = 4;


    pub fn get_raft_term(&self) -> u64 {
        self.raft_term
    }
    pub fn clear_raft_term(&mut self) {
        self.raft_term = 0;
    }

    // Param is passed by value, moved
    pub fn set_raft_term(&mut self, v: u64) {
        self.raft_term = v;
    }
}

impl ::protobuf::Message for ResponseHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cluster_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.member_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raft_term = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cluster_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cluster_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.member_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.member_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(3, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raft_term != 0 {
            my_size += ::protobuf::rt::value_size(4, self.raft_term, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cluster_id != 0 {
            os.write_uint64(1, self.cluster_id)?;
        }
        if self.member_id != 0 {
            os.write_uint64(2, self.member_id)?;
        }
        if self.revision != 0 {
            os.write_int64(3, self.revision)?;
        }
        if self.raft_term != 0 {
            os.write_uint64(4, self.raft_term)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseHeader {
        ResponseHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cluster_id",
                |m: &ResponseHeader| { &m.cluster_id },
                |m: &mut ResponseHeader| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "member_id",
                |m: &ResponseHeader| { &m.member_id },
                |m: &mut ResponseHeader| { &mut m.member_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "revision",
                |m: &ResponseHeader| { &m.revision },
                |m: &mut ResponseHeader| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "raft_term",
                |m: &ResponseHeader| { &m.raft_term },
                |m: &mut ResponseHeader| { &mut m.raft_term },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseHeader>(
                "ResponseHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseHeader {
        static instance: ::protobuf::rt::LazyV2<ResponseHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseHeader::new)
    }
}

impl ::protobuf::Clear for ResponseHeader {
    fn clear(&mut self) {
        self.cluster_id = 0;
        self.member_id = 0;
        self.revision = 0;
        self.raft_term = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RangeRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    pub limit: i64,
    pub revision: i64,
    pub sort_order: RangeRequest_SortOrder,
    pub sort_target: RangeRequest_SortTarget,
    pub serializable: bool,
    pub keys_only: bool,
    pub count_only: bool,
    pub min_mod_revision: i64,
    pub max_mod_revision: i64,
    pub min_create_revision: i64,
    pub max_create_revision: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RangeRequest {
    fn default() -> &'a RangeRequest {
        <RangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RangeRequest {
    pub fn new() -> RangeRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes range_end = 2;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }

    // int64 limit = 3;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // int64 revision = 4;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }

    // .etcdserverpb.RangeRequest.SortOrder sort_order = 5;


    pub fn get_sort_order(&self) -> RangeRequest_SortOrder {
        self.sort_order
    }
    pub fn clear_sort_order(&mut self) {
        self.sort_order = RangeRequest_SortOrder::NONE;
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: RangeRequest_SortOrder) {
        self.sort_order = v;
    }

    // .etcdserverpb.RangeRequest.SortTarget sort_target = 6;


    pub fn get_sort_target(&self) -> RangeRequest_SortTarget {
        self.sort_target
    }
    pub fn clear_sort_target(&mut self) {
        self.sort_target = RangeRequest_SortTarget::KEY;
    }

    // Param is passed by value, moved
    pub fn set_sort_target(&mut self, v: RangeRequest_SortTarget) {
        self.sort_target = v;
    }

    // bool serializable = 7;


    pub fn get_serializable(&self) -> bool {
        self.serializable
    }
    pub fn clear_serializable(&mut self) {
        self.serializable = false;
    }

    // Param is passed by value, moved
    pub fn set_serializable(&mut self, v: bool) {
        self.serializable = v;
    }

    // bool keys_only = 8;


    pub fn get_keys_only(&self) -> bool {
        self.keys_only
    }
    pub fn clear_keys_only(&mut self) {
        self.keys_only = false;
    }

    // Param is passed by value, moved
    pub fn set_keys_only(&mut self, v: bool) {
        self.keys_only = v;
    }

    // bool count_only = 9;


    pub fn get_count_only(&self) -> bool {
        self.count_only
    }
    pub fn clear_count_only(&mut self) {
        self.count_only = false;
    }

    // Param is passed by value, moved
    pub fn set_count_only(&mut self, v: bool) {
        self.count_only = v;
    }

    // int64 min_mod_revision = 10;


    pub fn get_min_mod_revision(&self) -> i64 {
        self.min_mod_revision
    }
    pub fn clear_min_mod_revision(&mut self) {
        self.min_mod_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_mod_revision(&mut self, v: i64) {
        self.min_mod_revision = v;
    }

    // int64 max_mod_revision = 11;


    pub fn get_max_mod_revision(&self) -> i64 {
        self.max_mod_revision
    }
    pub fn clear_max_mod_revision(&mut self) {
        self.max_mod_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_mod_revision(&mut self, v: i64) {
        self.max_mod_revision = v;
    }

    // int64 min_create_revision = 12;


    pub fn get_min_create_revision(&self) -> i64 {
        self.min_create_revision
    }
    pub fn clear_min_create_revision(&mut self) {
        self.min_create_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_create_revision(&mut self, v: i64) {
        self.min_create_revision = v;
    }

    // int64 max_create_revision = 13;


    pub fn get_max_create_revision(&self) -> i64 {
        self.max_create_revision
    }
    pub fn clear_max_create_revision(&mut self) {
        self.max_create_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_create_revision(&mut self, v: i64) {
        self.max_create_revision = v;
    }
}

impl ::protobuf::Message for RangeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sort_order, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sort_target, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.serializable = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.keys_only = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.count_only = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_mod_revision = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_mod_revision = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_create_revision = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_create_revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.range_end);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(4, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sort_order != RangeRequest_SortOrder::NONE {
            my_size += ::protobuf::rt::enum_size(5, self.sort_order);
        }
        if self.sort_target != RangeRequest_SortTarget::KEY {
            my_size += ::protobuf::rt::enum_size(6, self.sort_target);
        }
        if self.serializable != false {
            my_size += 2;
        }
        if self.keys_only != false {
            my_size += 2;
        }
        if self.count_only != false {
            my_size += 2;
        }
        if self.min_mod_revision != 0 {
            my_size += ::protobuf::rt::value_size(10, self.min_mod_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_mod_revision != 0 {
            my_size += ::protobuf::rt::value_size(11, self.max_mod_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_create_revision != 0 {
            my_size += ::protobuf::rt::value_size(12, self.min_create_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_create_revision != 0 {
            my_size += ::protobuf::rt::value_size(13, self.max_create_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(2, &self.range_end)?;
        }
        if self.limit != 0 {
            os.write_int64(3, self.limit)?;
        }
        if self.revision != 0 {
            os.write_int64(4, self.revision)?;
        }
        if self.sort_order != RangeRequest_SortOrder::NONE {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.sort_order))?;
        }
        if self.sort_target != RangeRequest_SortTarget::KEY {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.sort_target))?;
        }
        if self.serializable != false {
            os.write_bool(7, self.serializable)?;
        }
        if self.keys_only != false {
            os.write_bool(8, self.keys_only)?;
        }
        if self.count_only != false {
            os.write_bool(9, self.count_only)?;
        }
        if self.min_mod_revision != 0 {
            os.write_int64(10, self.min_mod_revision)?;
        }
        if self.max_mod_revision != 0 {
            os.write_int64(11, self.max_mod_revision)?;
        }
        if self.min_create_revision != 0 {
            os.write_int64(12, self.min_create_revision)?;
        }
        if self.max_create_revision != 0 {
            os.write_int64(13, self.max_create_revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RangeRequest {
        RangeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &RangeRequest| { &m.key },
                |m: &mut RangeRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "range_end",
                |m: &RangeRequest| { &m.range_end },
                |m: &mut RangeRequest| { &mut m.range_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &RangeRequest| { &m.limit },
                |m: &mut RangeRequest| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "revision",
                |m: &RangeRequest| { &m.revision },
                |m: &mut RangeRequest| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RangeRequest_SortOrder>>(
                "sort_order",
                |m: &RangeRequest| { &m.sort_order },
                |m: &mut RangeRequest| { &mut m.sort_order },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RangeRequest_SortTarget>>(
                "sort_target",
                |m: &RangeRequest| { &m.sort_target },
                |m: &mut RangeRequest| { &mut m.sort_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "serializable",
                |m: &RangeRequest| { &m.serializable },
                |m: &mut RangeRequest| { &mut m.serializable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "keys_only",
                |m: &RangeRequest| { &m.keys_only },
                |m: &mut RangeRequest| { &mut m.keys_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "count_only",
                |m: &RangeRequest| { &m.count_only },
                |m: &mut RangeRequest| { &mut m.count_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "min_mod_revision",
                |m: &RangeRequest| { &m.min_mod_revision },
                |m: &mut RangeRequest| { &mut m.min_mod_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_mod_revision",
                |m: &RangeRequest| { &m.max_mod_revision },
                |m: &mut RangeRequest| { &mut m.max_mod_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "min_create_revision",
                |m: &RangeRequest| { &m.min_create_revision },
                |m: &mut RangeRequest| { &mut m.min_create_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_create_revision",
                |m: &RangeRequest| { &m.max_create_revision },
                |m: &mut RangeRequest| { &mut m.max_create_revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RangeRequest>(
                "RangeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RangeRequest {
        static instance: ::protobuf::rt::LazyV2<RangeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RangeRequest::new)
    }
}

impl ::protobuf::Clear for RangeRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.range_end.clear();
        self.limit = 0;
        self.revision = 0;
        self.sort_order = RangeRequest_SortOrder::NONE;
        self.sort_target = RangeRequest_SortTarget::KEY;
        self.serializable = false;
        self.keys_only = false;
        self.count_only = false;
        self.min_mod_revision = 0;
        self.max_mod_revision = 0;
        self.min_create_revision = 0;
        self.max_create_revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RangeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RangeRequest_SortOrder {
    NONE = 0,
    ASCEND = 1,
    DESCEND = 2,
}

impl ::protobuf::ProtobufEnum for RangeRequest_SortOrder {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RangeRequest_SortOrder> {
        match value {
            0 => ::std::option::Option::Some(RangeRequest_SortOrder::NONE),
            1 => ::std::option::Option::Some(RangeRequest_SortOrder::ASCEND),
            2 => ::std::option::Option::Some(RangeRequest_SortOrder::DESCEND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RangeRequest_SortOrder] = &[
            RangeRequest_SortOrder::NONE,
            RangeRequest_SortOrder::ASCEND,
            RangeRequest_SortOrder::DESCEND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RangeRequest_SortOrder>("RangeRequest.SortOrder", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RangeRequest_SortOrder {
}

impl ::std::default::Default for RangeRequest_SortOrder {
    fn default() -> Self {
        RangeRequest_SortOrder::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeRequest_SortOrder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RangeRequest_SortTarget {
    KEY = 0,
    VERSION = 1,
    CREATE = 2,
    MOD = 3,
    VALUE = 4,
}

impl ::protobuf::ProtobufEnum for RangeRequest_SortTarget {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RangeRequest_SortTarget> {
        match value {
            0 => ::std::option::Option::Some(RangeRequest_SortTarget::KEY),
            1 => ::std::option::Option::Some(RangeRequest_SortTarget::VERSION),
            2 => ::std::option::Option::Some(RangeRequest_SortTarget::CREATE),
            3 => ::std::option::Option::Some(RangeRequest_SortTarget::MOD),
            4 => ::std::option::Option::Some(RangeRequest_SortTarget::VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RangeRequest_SortTarget] = &[
            RangeRequest_SortTarget::KEY,
            RangeRequest_SortTarget::VERSION,
            RangeRequest_SortTarget::CREATE,
            RangeRequest_SortTarget::MOD,
            RangeRequest_SortTarget::VALUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RangeRequest_SortTarget>("RangeRequest.SortTarget", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RangeRequest_SortTarget {
}

impl ::std::default::Default for RangeRequest_SortTarget {
    fn default() -> Self {
        RangeRequest_SortTarget::KEY
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeRequest_SortTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RangeResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub kvs: ::protobuf::RepeatedField<super::kv::KeyValue>,
    pub more: bool,
    pub count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RangeResponse {
    fn default() -> &'a RangeResponse {
        <RangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl RangeResponse {
    pub fn new() -> RangeResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .mvccpb.KeyValue kvs = 2;


    pub fn get_kvs(&self) -> &[super::kv::KeyValue] {
        &self.kvs
    }
    pub fn clear_kvs(&mut self) {
        self.kvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_kvs(&mut self, v: ::protobuf::RepeatedField<super::kv::KeyValue>) {
        self.kvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kvs(&mut self) -> &mut ::protobuf::RepeatedField<super::kv::KeyValue> {
        &mut self.kvs
    }

    // Take field
    pub fn take_kvs(&mut self) -> ::protobuf::RepeatedField<super::kv::KeyValue> {
        ::std::mem::replace(&mut self.kvs, ::protobuf::RepeatedField::new())
    }

    // bool more = 3;


    pub fn get_more(&self) -> bool {
        self.more
    }
    pub fn clear_more(&mut self) {
        self.more = false;
    }

    // Param is passed by value, moved
    pub fn set_more(&mut self, v: bool) {
        self.more = v;
    }

    // int64 count = 4;


    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }
}

impl ::protobuf::Message for RangeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kvs)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.more = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.kvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.more != false {
            my_size += 2;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(4, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.kvs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.more != false {
            os.write_bool(3, self.more)?;
        }
        if self.count != 0 {
            os.write_int64(4, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RangeResponse {
        RangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &RangeResponse| { &m.header },
                |m: &mut RangeResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::KeyValue>>(
                "kvs",
                |m: &RangeResponse| { &m.kvs },
                |m: &mut RangeResponse| { &mut m.kvs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "more",
                |m: &RangeResponse| { &m.more },
                |m: &mut RangeResponse| { &mut m.more },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "count",
                |m: &RangeResponse| { &m.count },
                |m: &mut RangeResponse| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RangeResponse>(
                "RangeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RangeResponse {
        static instance: ::protobuf::rt::LazyV2<RangeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RangeResponse::new)
    }
}

impl ::protobuf::Clear for RangeResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.kvs.clear();
        self.more = false;
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub lease: i64,
    pub prev_kv: bool,
    pub ignore_value: bool,
    pub ignore_lease: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PutRequest {
    fn default() -> &'a PutRequest {
        <PutRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutRequest {
    pub fn new() -> PutRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // int64 lease = 3;


    pub fn get_lease(&self) -> i64 {
        self.lease
    }
    pub fn clear_lease(&mut self) {
        self.lease = 0;
    }

    // Param is passed by value, moved
    pub fn set_lease(&mut self, v: i64) {
        self.lease = v;
    }

    // bool prev_kv = 4;


    pub fn get_prev_kv(&self) -> bool {
        self.prev_kv
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: bool) {
        self.prev_kv = v;
    }

    // bool ignore_value = 5;


    pub fn get_ignore_value(&self) -> bool {
        self.ignore_value
    }
    pub fn clear_ignore_value(&mut self) {
        self.ignore_value = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_value(&mut self, v: bool) {
        self.ignore_value = v;
    }

    // bool ignore_lease = 6;


    pub fn get_ignore_lease(&self) -> bool {
        self.ignore_lease
    }
    pub fn clear_ignore_lease(&mut self) {
        self.ignore_lease = false;
    }

    // Param is passed by value, moved
    pub fn set_ignore_lease(&mut self, v: bool) {
        self.ignore_lease = v;
    }
}

impl ::protobuf::Message for PutRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lease = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prev_kv = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_lease = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.lease != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lease, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prev_kv != false {
            my_size += 2;
        }
        if self.ignore_value != false {
            my_size += 2;
        }
        if self.ignore_lease != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.lease != 0 {
            os.write_int64(3, self.lease)?;
        }
        if self.prev_kv != false {
            os.write_bool(4, self.prev_kv)?;
        }
        if self.ignore_value != false {
            os.write_bool(5, self.ignore_value)?;
        }
        if self.ignore_lease != false {
            os.write_bool(6, self.ignore_lease)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutRequest {
        PutRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &PutRequest| { &m.key },
                |m: &mut PutRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &PutRequest| { &m.value },
                |m: &mut PutRequest| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lease",
                |m: &PutRequest| { &m.lease },
                |m: &mut PutRequest| { &mut m.lease },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prev_kv",
                |m: &PutRequest| { &m.prev_kv },
                |m: &mut PutRequest| { &mut m.prev_kv },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ignore_value",
                |m: &PutRequest| { &m.ignore_value },
                |m: &mut PutRequest| { &mut m.ignore_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ignore_lease",
                |m: &PutRequest| { &m.ignore_lease },
                |m: &mut PutRequest| { &mut m.ignore_lease },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PutRequest>(
                "PutRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PutRequest {
        static instance: ::protobuf::rt::LazyV2<PutRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PutRequest::new)
    }
}

impl ::protobuf::Clear for PutRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.lease = 0;
        self.prev_kv = false;
        self.ignore_value = false;
        self.ignore_lease = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub prev_kv: ::protobuf::SingularPtrField<super::kv::KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PutResponse {
    fn default() -> &'a PutResponse {
        <PutResponse as ::protobuf::Message>::default_instance()
    }
}

impl PutResponse {
    pub fn new() -> PutResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // .mvccpb.KeyValue prev_kv = 2;


    pub fn get_prev_kv(&self) -> &super::kv::KeyValue {
        self.prev_kv.as_ref().unwrap_or_else(|| <super::kv::KeyValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv.clear();
    }

    pub fn has_prev_kv(&self) -> bool {
        self.prev_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: super::kv::KeyValue) {
        self.prev_kv = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev_kv(&mut self) -> &mut super::kv::KeyValue {
        if self.prev_kv.is_none() {
            self.prev_kv.set_default();
        }
        self.prev_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_prev_kv(&mut self) -> super::kv::KeyValue {
        self.prev_kv.take().unwrap_or_else(|| super::kv::KeyValue::new())
    }
}

impl ::protobuf::Message for PutResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prev_kv {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prev_kv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.prev_kv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.prev_kv.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutResponse {
        PutResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &PutResponse| { &m.header },
                |m: &mut PutResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::KeyValue>>(
                "prev_kv",
                |m: &PutResponse| { &m.prev_kv },
                |m: &mut PutResponse| { &mut m.prev_kv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PutResponse>(
                "PutResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PutResponse {
        static instance: ::protobuf::rt::LazyV2<PutResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PutResponse::new)
    }
}

impl ::protobuf::Clear for PutResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.prev_kv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRangeRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    pub prev_kv: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRangeRequest {
    fn default() -> &'a DeleteRangeRequest {
        <DeleteRangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRangeRequest {
    pub fn new() -> DeleteRangeRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes range_end = 2;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }

    // bool prev_kv = 3;


    pub fn get_prev_kv(&self) -> bool {
        self.prev_kv
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: bool) {
        self.prev_kv = v;
    }
}

impl ::protobuf::Message for DeleteRangeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prev_kv = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.range_end);
        }
        if self.prev_kv != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(2, &self.range_end)?;
        }
        if self.prev_kv != false {
            os.write_bool(3, self.prev_kv)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRangeRequest {
        DeleteRangeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &DeleteRangeRequest| { &m.key },
                |m: &mut DeleteRangeRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "range_end",
                |m: &DeleteRangeRequest| { &m.range_end },
                |m: &mut DeleteRangeRequest| { &mut m.range_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prev_kv",
                |m: &DeleteRangeRequest| { &m.prev_kv },
                |m: &mut DeleteRangeRequest| { &mut m.prev_kv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRangeRequest>(
                "DeleteRangeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRangeRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteRangeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRangeRequest::new)
    }
}

impl ::protobuf::Clear for DeleteRangeRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.range_end.clear();
        self.prev_kv = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRangeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRangeResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub deleted: i64,
    pub prev_kvs: ::protobuf::RepeatedField<super::kv::KeyValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRangeResponse {
    fn default() -> &'a DeleteRangeResponse {
        <DeleteRangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRangeResponse {
    pub fn new() -> DeleteRangeResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 deleted = 2;


    pub fn get_deleted(&self) -> i64 {
        self.deleted
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = 0;
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: i64) {
        self.deleted = v;
    }

    // repeated .mvccpb.KeyValue prev_kvs = 3;


    pub fn get_prev_kvs(&self) -> &[super::kv::KeyValue] {
        &self.prev_kvs
    }
    pub fn clear_prev_kvs(&mut self) {
        self.prev_kvs.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev_kvs(&mut self, v: ::protobuf::RepeatedField<super::kv::KeyValue>) {
        self.prev_kvs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prev_kvs(&mut self) -> &mut ::protobuf::RepeatedField<super::kv::KeyValue> {
        &mut self.prev_kvs
    }

    // Take field
    pub fn take_prev_kvs(&mut self) -> ::protobuf::RepeatedField<super::kv::KeyValue> {
        ::std::mem::replace(&mut self.prev_kvs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteRangeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prev_kvs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deleted = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prev_kvs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.deleted != 0 {
            my_size += ::protobuf::rt::value_size(2, self.deleted, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.prev_kvs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.deleted != 0 {
            os.write_int64(2, self.deleted)?;
        }
        for v in &self.prev_kvs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRangeResponse {
        DeleteRangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &DeleteRangeResponse| { &m.header },
                |m: &mut DeleteRangeResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "deleted",
                |m: &DeleteRangeResponse| { &m.deleted },
                |m: &mut DeleteRangeResponse| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::KeyValue>>(
                "prev_kvs",
                |m: &DeleteRangeResponse| { &m.prev_kvs },
                |m: &mut DeleteRangeResponse| { &mut m.prev_kvs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRangeResponse>(
                "DeleteRangeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRangeResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteRangeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRangeResponse::new)
    }
}

impl ::protobuf::Clear for DeleteRangeResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.deleted = 0;
        self.prev_kvs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestOp {
    // message oneof groups
    pub request: ::std::option::Option<RequestOp_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestOp {
    fn default() -> &'a RequestOp {
        <RequestOp as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RequestOp_oneof_request {
    request_range(RangeRequest),
    request_put(PutRequest),
    request_delete_range(DeleteRangeRequest),
    request_txn(TxnRequest),
}

impl RequestOp {
    pub fn new() -> RequestOp {
        ::std::default::Default::default()
    }

    // .etcdserverpb.RangeRequest request_range = 1;


    pub fn get_request_range(&self) -> &RangeRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_range(ref v)) => v,
            _ => <RangeRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_range(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_range(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_range(&mut self, v: RangeRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_range(&mut self) -> &mut RangeRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_range(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_range(RangeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_range(&mut self) -> RangeRequest {
        if self.has_request_range() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_range(v)) => v,
                _ => panic!(),
            }
        } else {
            RangeRequest::new()
        }
    }

    // .etcdserverpb.PutRequest request_put = 2;


    pub fn get_request_put(&self) -> &PutRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_put(ref v)) => v,
            _ => <PutRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_put(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_put(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_put(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_put(&mut self, v: PutRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_put(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_put(&mut self) -> &mut PutRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_put(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_put(PutRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_put(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_put(&mut self) -> PutRequest {
        if self.has_request_put() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_put(v)) => v,
                _ => panic!(),
            }
        } else {
            PutRequest::new()
        }
    }

    // .etcdserverpb.DeleteRangeRequest request_delete_range = 3;


    pub fn get_request_delete_range(&self) -> &DeleteRangeRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(ref v)) => v,
            _ => <DeleteRangeRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_delete_range(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_delete_range(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_delete_range(&mut self, v: DeleteRangeRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_delete_range(&mut self) -> &mut DeleteRangeRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(DeleteRangeRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_delete_range(&mut self) -> DeleteRangeRequest {
        if self.has_request_delete_range() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteRangeRequest::new()
        }
    }

    // .etcdserverpb.TxnRequest request_txn = 4;


    pub fn get_request_txn(&self) -> &TxnRequest {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_txn(ref v)) => v,
            _ => <TxnRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_txn(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_txn(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_txn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_txn(&mut self, v: TxnRequest) {
        self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_txn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_txn(&mut self) -> &mut TxnRequest {
        if let ::std::option::Option::Some(RequestOp_oneof_request::request_txn(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_txn(TxnRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(RequestOp_oneof_request::request_txn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_txn(&mut self) -> TxnRequest {
        if self.has_request_txn() {
            match self.request.take() {
                ::std::option::Option::Some(RequestOp_oneof_request::request_txn(v)) => v,
                _ => panic!(),
            }
        } else {
            TxnRequest::new()
        }
    }
}

impl ::protobuf::Message for RequestOp {
    fn is_initialized(&self) -> bool {
        if let Some(RequestOp_oneof_request::request_range(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestOp_oneof_request::request_put(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestOp_oneof_request::request_delete_range(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RequestOp_oneof_request::request_txn(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_range(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_put(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_delete_range(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(RequestOp_oneof_request::request_txn(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &RequestOp_oneof_request::request_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestOp_oneof_request::request_put(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestOp_oneof_request::request_delete_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RequestOp_oneof_request::request_txn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &RequestOp_oneof_request::request_range(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestOp_oneof_request::request_put(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestOp_oneof_request::request_delete_range(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RequestOp_oneof_request::request_txn(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestOp {
        RequestOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RangeRequest>(
                "request_range",
                RequestOp::has_request_range,
                RequestOp::get_request_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutRequest>(
                "request_put",
                RequestOp::has_request_put,
                RequestOp::get_request_put,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DeleteRangeRequest>(
                "request_delete_range",
                RequestOp::has_request_delete_range,
                RequestOp::get_request_delete_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TxnRequest>(
                "request_txn",
                RequestOp::has_request_txn,
                RequestOp::get_request_txn,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequestOp>(
                "RequestOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequestOp {
        static instance: ::protobuf::rt::LazyV2<RequestOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequestOp::new)
    }
}

impl ::protobuf::Clear for RequestOp {
    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseOp {
    // message oneof groups
    pub response: ::std::option::Option<ResponseOp_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResponseOp {
    fn default() -> &'a ResponseOp {
        <ResponseOp as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ResponseOp_oneof_response {
    response_range(RangeResponse),
    response_put(PutResponse),
    response_delete_range(DeleteRangeResponse),
    response_txn(TxnResponse),
}

impl ResponseOp {
    pub fn new() -> ResponseOp {
        ::std::default::Default::default()
    }

    // .etcdserverpb.RangeResponse response_range = 1;


    pub fn get_response_range(&self) -> &RangeResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_range(ref v)) => v,
            _ => <RangeResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_range(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_range(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_range(&mut self, v: RangeResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_range(&mut self) -> &mut RangeResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_range(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_range(RangeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_range(&mut self) -> RangeResponse {
        if self.has_response_range() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_range(v)) => v,
                _ => panic!(),
            }
        } else {
            RangeResponse::new()
        }
    }

    // .etcdserverpb.PutResponse response_put = 2;


    pub fn get_response_put(&self) -> &PutResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_put(ref v)) => v,
            _ => <PutResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_put(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_put(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_put(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_put(&mut self, v: PutResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_put(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_put(&mut self) -> &mut PutResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_put(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_put(PutResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_put(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_put(&mut self) -> PutResponse {
        if self.has_response_put() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_put(v)) => v,
                _ => panic!(),
            }
        } else {
            PutResponse::new()
        }
    }

    // .etcdserverpb.DeleteRangeResponse response_delete_range = 3;


    pub fn get_response_delete_range(&self) -> &DeleteRangeResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(ref v)) => v,
            _ => <DeleteRangeResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_delete_range(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_delete_range(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_delete_range(&mut self, v: DeleteRangeResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_delete_range(&mut self) -> &mut DeleteRangeResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(DeleteRangeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_delete_range(&mut self) -> DeleteRangeResponse {
        if self.has_response_delete_range() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteRangeResponse::new()
        }
    }

    // .etcdserverpb.TxnResponse response_txn = 4;


    pub fn get_response_txn(&self) -> &TxnResponse {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(ref v)) => v,
            _ => <TxnResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_txn(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_txn(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_txn(&mut self, v: TxnResponse) {
        self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_txn(&mut self) -> &mut TxnResponse {
        if let ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(TxnResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_txn(&mut self) -> TxnResponse {
        if self.has_response_txn() {
            match self.response.take() {
                ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(v)) => v,
                _ => panic!(),
            }
        } else {
            TxnResponse::new()
        }
    }
}

impl ::protobuf::Message for ResponseOp {
    fn is_initialized(&self) -> bool {
        if let Some(ResponseOp_oneof_response::response_range(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseOp_oneof_response::response_put(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseOp_oneof_response::response_delete_range(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ResponseOp_oneof_response::response_txn(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_range(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_put(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_delete_range(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ResponseOp_oneof_response::response_txn(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &ResponseOp_oneof_response::response_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseOp_oneof_response::response_put(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseOp_oneof_response::response_delete_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ResponseOp_oneof_response::response_txn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &ResponseOp_oneof_response::response_range(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseOp_oneof_response::response_put(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseOp_oneof_response::response_delete_range(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ResponseOp_oneof_response::response_txn(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseOp {
        ResponseOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RangeResponse>(
                "response_range",
                ResponseOp::has_response_range,
                ResponseOp::get_response_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PutResponse>(
                "response_put",
                ResponseOp::has_response_put,
                ResponseOp::get_response_put,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DeleteRangeResponse>(
                "response_delete_range",
                ResponseOp::has_response_delete_range,
                ResponseOp::get_response_delete_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TxnResponse>(
                "response_txn",
                ResponseOp::has_response_txn,
                ResponseOp::get_response_txn,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResponseOp>(
                "ResponseOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResponseOp {
        static instance: ::protobuf::rt::LazyV2<ResponseOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResponseOp::new)
    }
}

impl ::protobuf::Clear for ResponseOp {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Compare {
    // message fields
    pub result: Compare_CompareResult,
    pub target: Compare_CompareTarget,
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    // message oneof groups
    pub target_union: ::std::option::Option<Compare_oneof_target_union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Compare {
    fn default() -> &'a Compare {
        <Compare as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Compare_oneof_target_union {
    version(i64),
    create_revision(i64),
    mod_revision(i64),
    value(::std::vec::Vec<u8>),
}

impl Compare {
    pub fn new() -> Compare {
        ::std::default::Default::default()
    }

    // .etcdserverpb.Compare.CompareResult result = 1;


    pub fn get_result(&self) -> Compare_CompareResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = Compare_CompareResult::EQUAL;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Compare_CompareResult) {
        self.result = v;
    }

    // .etcdserverpb.Compare.CompareTarget target = 2;


    pub fn get_target(&self) -> Compare_CompareTarget {
        self.target
    }
    pub fn clear_target(&mut self) {
        self.target = Compare_CompareTarget::VERSION;
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Compare_CompareTarget) {
        self.target = v;
    }

    // bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // int64 version = 4;


    pub fn get_version(&self) -> i64 {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::version(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_version(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::version(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::version(v))
    }

    // int64 create_revision = 5;


    pub fn get_create_revision(&self) -> i64 {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::create_revision(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_create_revision(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_create_revision(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::create_revision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_revision(&mut self, v: i64) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::create_revision(v))
    }

    // int64 mod_revision = 6;


    pub fn get_mod_revision(&self) -> i64 {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_mod_revision(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_mod_revision(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mod_revision(&mut self, v: i64) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(v))
    }

    // bytes value = 7;


    pub fn get_value(&self) -> &[u8] {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::value(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_value(&mut self) {
        self.target_union = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Compare_oneof_target_union::value(_)) = self.target_union {
        } else {
            self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::value(::std::vec::Vec::new()));
        }
        match self.target_union {
            ::std::option::Option::Some(Compare_oneof_target_union::value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_value() {
            match self.target_union.take() {
                ::std::option::Option::Some(Compare_oneof_target_union::value(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bytes range_end = 8;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Compare {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.target, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::version(is.read_int64()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::create_revision(is.read_int64()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::mod_revision(is.read_int64()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_union = ::std::option::Option::Some(Compare_oneof_target_union::value(is.read_bytes()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != Compare_CompareResult::EQUAL {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if self.target != Compare_CompareTarget::VERSION {
            my_size += ::protobuf::rt::enum_size(2, self.target);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.range_end);
        }
        if let ::std::option::Option::Some(ref v) = self.target_union {
            match v {
                &Compare_oneof_target_union::version(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Compare_oneof_target_union::create_revision(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Compare_oneof_target_union::mod_revision(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Compare_oneof_target_union::value(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != Compare_CompareResult::EQUAL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        if self.target != Compare_CompareTarget::VERSION {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.target))?;
        }
        if !self.key.is_empty() {
            os.write_bytes(3, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(8, &self.range_end)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target_union {
            match v {
                &Compare_oneof_target_union::version(v) => {
                    os.write_int64(4, v)?;
                },
                &Compare_oneof_target_union::create_revision(v) => {
                    os.write_int64(5, v)?;
                },
                &Compare_oneof_target_union::mod_revision(v) => {
                    os.write_int64(6, v)?;
                },
                &Compare_oneof_target_union::value(ref v) => {
                    os.write_bytes(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Compare {
        Compare::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Compare_CompareResult>>(
                "result",
                |m: &Compare| { &m.result },
                |m: &mut Compare| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Compare_CompareTarget>>(
                "target",
                |m: &Compare| { &m.target },
                |m: &mut Compare| { &mut m.target },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &Compare| { &m.key },
                |m: &mut Compare| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "version",
                Compare::has_version,
                Compare::get_version,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "create_revision",
                Compare::has_create_revision,
                Compare::get_create_revision,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "mod_revision",
                Compare::has_mod_revision,
                Compare::get_mod_revision,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "value",
                Compare::has_value,
                Compare::get_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "range_end",
                |m: &Compare| { &m.range_end },
                |m: &mut Compare| { &mut m.range_end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Compare>(
                "Compare",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Compare {
        static instance: ::protobuf::rt::LazyV2<Compare> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Compare::new)
    }
}

impl ::protobuf::Clear for Compare {
    fn clear(&mut self) {
        self.result = Compare_CompareResult::EQUAL;
        self.target = Compare_CompareTarget::VERSION;
        self.key.clear();
        self.target_union = ::std::option::Option::None;
        self.target_union = ::std::option::Option::None;
        self.target_union = ::std::option::Option::None;
        self.target_union = ::std::option::Option::None;
        self.range_end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Compare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Compare {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Compare_CompareResult {
    EQUAL = 0,
    GREATER = 1,
    LESS = 2,
    NOT_EQUAL = 3,
}

impl ::protobuf::ProtobufEnum for Compare_CompareResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Compare_CompareResult> {
        match value {
            0 => ::std::option::Option::Some(Compare_CompareResult::EQUAL),
            1 => ::std::option::Option::Some(Compare_CompareResult::GREATER),
            2 => ::std::option::Option::Some(Compare_CompareResult::LESS),
            3 => ::std::option::Option::Some(Compare_CompareResult::NOT_EQUAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Compare_CompareResult] = &[
            Compare_CompareResult::EQUAL,
            Compare_CompareResult::GREATER,
            Compare_CompareResult::LESS,
            Compare_CompareResult::NOT_EQUAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Compare_CompareResult>("Compare.CompareResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Compare_CompareResult {
}

impl ::std::default::Default for Compare_CompareResult {
    fn default() -> Self {
        Compare_CompareResult::EQUAL
    }
}

impl ::protobuf::reflect::ProtobufValue for Compare_CompareResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Compare_CompareTarget {
    VERSION = 0,
    CREATE = 1,
    MOD = 2,
    VALUE = 3,
}

impl ::protobuf::ProtobufEnum for Compare_CompareTarget {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Compare_CompareTarget> {
        match value {
            0 => ::std::option::Option::Some(Compare_CompareTarget::VERSION),
            1 => ::std::option::Option::Some(Compare_CompareTarget::CREATE),
            2 => ::std::option::Option::Some(Compare_CompareTarget::MOD),
            3 => ::std::option::Option::Some(Compare_CompareTarget::VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Compare_CompareTarget] = &[
            Compare_CompareTarget::VERSION,
            Compare_CompareTarget::CREATE,
            Compare_CompareTarget::MOD,
            Compare_CompareTarget::VALUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Compare_CompareTarget>("Compare.CompareTarget", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Compare_CompareTarget {
}

impl ::std::default::Default for Compare_CompareTarget {
    fn default() -> Self {
        Compare_CompareTarget::VERSION
    }
}

impl ::protobuf::reflect::ProtobufValue for Compare_CompareTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnRequest {
    // message fields
    pub compare: ::protobuf::RepeatedField<Compare>,
    pub success: ::protobuf::RepeatedField<RequestOp>,
    pub failure: ::protobuf::RepeatedField<RequestOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnRequest {
    fn default() -> &'a TxnRequest {
        <TxnRequest as ::protobuf::Message>::default_instance()
    }
}

impl TxnRequest {
    pub fn new() -> TxnRequest {
        ::std::default::Default::default()
    }

    // repeated .etcdserverpb.Compare compare = 1;


    pub fn get_compare(&self) -> &[Compare] {
        &self.compare
    }
    pub fn clear_compare(&mut self) {
        self.compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_compare(&mut self, v: ::protobuf::RepeatedField<Compare>) {
        self.compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compare(&mut self) -> &mut ::protobuf::RepeatedField<Compare> {
        &mut self.compare
    }

    // Take field
    pub fn take_compare(&mut self) -> ::protobuf::RepeatedField<Compare> {
        ::std::mem::replace(&mut self.compare, ::protobuf::RepeatedField::new())
    }

    // repeated .etcdserverpb.RequestOp success = 2;


    pub fn get_success(&self) -> &[RequestOp] {
        &self.success
    }
    pub fn clear_success(&mut self) {
        self.success.clear();
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: ::protobuf::RepeatedField<RequestOp>) {
        self.success = v;
    }

    // Mutable pointer to the field.
    pub fn mut_success(&mut self) -> &mut ::protobuf::RepeatedField<RequestOp> {
        &mut self.success
    }

    // Take field
    pub fn take_success(&mut self) -> ::protobuf::RepeatedField<RequestOp> {
        ::std::mem::replace(&mut self.success, ::protobuf::RepeatedField::new())
    }

    // repeated .etcdserverpb.RequestOp failure = 3;


    pub fn get_failure(&self) -> &[RequestOp] {
        &self.failure
    }
    pub fn clear_failure(&mut self) {
        self.failure.clear();
    }

    // Param is passed by value, moved
    pub fn set_failure(&mut self, v: ::protobuf::RepeatedField<RequestOp>) {
        self.failure = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failure(&mut self) -> &mut ::protobuf::RepeatedField<RequestOp> {
        &mut self.failure
    }

    // Take field
    pub fn take_failure(&mut self) -> ::protobuf::RepeatedField<RequestOp> {
        ::std::mem::replace(&mut self.failure, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TxnRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.compare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.success {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.failure {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.compare)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.success)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.failure)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.success {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.failure {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.compare {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.success {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.failure {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnRequest {
        TxnRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Compare>>(
                "compare",
                |m: &TxnRequest| { &m.compare },
                |m: &mut TxnRequest| { &mut m.compare },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestOp>>(
                "success",
                |m: &TxnRequest| { &m.success },
                |m: &mut TxnRequest| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequestOp>>(
                "failure",
                |m: &TxnRequest| { &m.failure },
                |m: &mut TxnRequest| { &mut m.failure },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxnRequest>(
                "TxnRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TxnRequest {
        static instance: ::protobuf::rt::LazyV2<TxnRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxnRequest::new)
    }
}

impl ::protobuf::Clear for TxnRequest {
    fn clear(&mut self) {
        self.compare.clear();
        self.success.clear();
        self.failure.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxnRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TxnResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub succeeded: bool,
    pub responses: ::protobuf::RepeatedField<ResponseOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxnResponse {
    fn default() -> &'a TxnResponse {
        <TxnResponse as ::protobuf::Message>::default_instance()
    }
}

impl TxnResponse {
    pub fn new() -> TxnResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // bool succeeded = 2;


    pub fn get_succeeded(&self) -> bool {
        self.succeeded
    }
    pub fn clear_succeeded(&mut self) {
        self.succeeded = false;
    }

    // Param is passed by value, moved
    pub fn set_succeeded(&mut self, v: bool) {
        self.succeeded = v;
    }

    // repeated .etcdserverpb.ResponseOp responses = 3;


    pub fn get_responses(&self) -> &[ResponseOp] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<ResponseOp>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<ResponseOp> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<ResponseOp> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TxnResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.succeeded = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.succeeded != false {
            my_size += 2;
        }
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.succeeded != false {
            os.write_bool(2, self.succeeded)?;
        }
        for v in &self.responses {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxnResponse {
        TxnResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &TxnResponse| { &m.header },
                |m: &mut TxnResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "succeeded",
                |m: &TxnResponse| { &m.succeeded },
                |m: &mut TxnResponse| { &mut m.succeeded },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseOp>>(
                "responses",
                |m: &TxnResponse| { &m.responses },
                |m: &mut TxnResponse| { &mut m.responses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxnResponse>(
                "TxnResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TxnResponse {
        static instance: ::protobuf::rt::LazyV2<TxnResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TxnResponse::new)
    }
}

impl ::protobuf::Clear for TxnResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.succeeded = false;
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxnResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactionRequest {
    // message fields
    pub revision: i64,
    pub physical: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactionRequest {
    fn default() -> &'a CompactionRequest {
        <CompactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompactionRequest {
    pub fn new() -> CompactionRequest {
        ::std::default::Default::default()
    }

    // int64 revision = 1;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }

    // bool physical = 2;


    pub fn get_physical(&self) -> bool {
        self.physical
    }
    pub fn clear_physical(&mut self) {
        self.physical = false;
    }

    // Param is passed by value, moved
    pub fn set_physical(&mut self, v: bool) {
        self.physical = v;
    }
}

impl ::protobuf::Message for CompactionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.physical = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(1, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.physical != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.revision != 0 {
            os.write_int64(1, self.revision)?;
        }
        if self.physical != false {
            os.write_bool(2, self.physical)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactionRequest {
        CompactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "revision",
                |m: &CompactionRequest| { &m.revision },
                |m: &mut CompactionRequest| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "physical",
                |m: &CompactionRequest| { &m.physical },
                |m: &mut CompactionRequest| { &mut m.physical },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompactionRequest>(
                "CompactionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompactionRequest {
        static instance: ::protobuf::rt::LazyV2<CompactionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompactionRequest::new)
    }
}

impl ::protobuf::Clear for CompactionRequest {
    fn clear(&mut self) {
        self.revision = 0;
        self.physical = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactionResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactionResponse {
    fn default() -> &'a CompactionResponse {
        <CompactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompactionResponse {
    pub fn new() -> CompactionResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for CompactionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactionResponse {
        CompactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &CompactionResponse| { &m.header },
                |m: &mut CompactionResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompactionResponse>(
                "CompactionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompactionResponse {
        static instance: ::protobuf::rt::LazyV2<CompactionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompactionResponse::new)
    }
}

impl ::protobuf::Clear for CompactionResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashRequest {
    fn default() -> &'a HashRequest {
        <HashRequest as ::protobuf::Message>::default_instance()
    }
}

impl HashRequest {
    pub fn new() -> HashRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HashRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashRequest {
        HashRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HashRequest>(
                "HashRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HashRequest {
        static instance: ::protobuf::rt::LazyV2<HashRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HashRequest::new)
    }
}

impl ::protobuf::Clear for HashRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub hash: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashResponse {
    fn default() -> &'a HashResponse {
        <HashResponse as ::protobuf::Message>::default_instance()
    }
}

impl HashResponse {
    pub fn new() -> HashResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // uint32 hash = 2;


    pub fn get_hash(&self) -> u32 {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = v;
    }
}

impl ::protobuf::Message for HashResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hash != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hash, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hash != 0 {
            os.write_uint32(2, self.hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashResponse {
        HashResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &HashResponse| { &m.header },
                |m: &mut HashResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hash",
                |m: &HashResponse| { &m.hash },
                |m: &mut HashResponse| { &mut m.hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HashResponse>(
                "HashResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HashResponse {
        static instance: ::protobuf::rt::LazyV2<HashResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HashResponse::new)
    }
}

impl ::protobuf::Clear for HashResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.hash = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashKVRequest {
    // message fields
    pub revision: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashKVRequest {
    fn default() -> &'a HashKVRequest {
        <HashKVRequest as ::protobuf::Message>::default_instance()
    }
}

impl HashKVRequest {
    pub fn new() -> HashKVRequest {
        ::std::default::Default::default()
    }

    // int64 revision = 1;


    pub fn get_revision(&self) -> i64 {
        self.revision
    }
    pub fn clear_revision(&mut self) {
        self.revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: i64) {
        self.revision = v;
    }
}

impl ::protobuf::Message for HashKVRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.revision != 0 {
            my_size += ::protobuf::rt::value_size(1, self.revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.revision != 0 {
            os.write_int64(1, self.revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashKVRequest {
        HashKVRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "revision",
                |m: &HashKVRequest| { &m.revision },
                |m: &mut HashKVRequest| { &mut m.revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HashKVRequest>(
                "HashKVRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HashKVRequest {
        static instance: ::protobuf::rt::LazyV2<HashKVRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HashKVRequest::new)
    }
}

impl ::protobuf::Clear for HashKVRequest {
    fn clear(&mut self) {
        self.revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashKVRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashKVRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HashKVResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub hash: u32,
    pub compact_revision: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HashKVResponse {
    fn default() -> &'a HashKVResponse {
        <HashKVResponse as ::protobuf::Message>::default_instance()
    }
}

impl HashKVResponse {
    pub fn new() -> HashKVResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // uint32 hash = 2;


    pub fn get_hash(&self) -> u32 {
        self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash = 0;
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = v;
    }

    // int64 compact_revision = 3;


    pub fn get_compact_revision(&self) -> i64 {
        self.compact_revision
    }
    pub fn clear_compact_revision(&mut self) {
        self.compact_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_compact_revision(&mut self, v: i64) {
        self.compact_revision = v;
    }
}

impl ::protobuf::Message for HashKVResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hash = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compact_revision = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hash != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hash, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compact_revision != 0 {
            my_size += ::protobuf::rt::value_size(3, self.compact_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hash != 0 {
            os.write_uint32(2, self.hash)?;
        }
        if self.compact_revision != 0 {
            os.write_int64(3, self.compact_revision)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HashKVResponse {
        HashKVResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &HashKVResponse| { &m.header },
                |m: &mut HashKVResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hash",
                |m: &HashKVResponse| { &m.hash },
                |m: &mut HashKVResponse| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compact_revision",
                |m: &HashKVResponse| { &m.compact_revision },
                |m: &mut HashKVResponse| { &mut m.compact_revision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HashKVResponse>(
                "HashKVResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HashKVResponse {
        static instance: ::protobuf::rt::LazyV2<HashKVResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HashKVResponse::new)
    }
}

impl ::protobuf::Clear for HashKVResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.hash = 0;
        self.compact_revision = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HashKVResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HashKVResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotRequest {
    fn default() -> &'a SnapshotRequest {
        <SnapshotRequest as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotRequest {
    pub fn new() -> SnapshotRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SnapshotRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotRequest {
        SnapshotRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotRequest>(
                "SnapshotRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotRequest {
        static instance: ::protobuf::rt::LazyV2<SnapshotRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotRequest::new)
    }
}

impl ::protobuf::Clear for SnapshotRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub remaining_bytes: u64,
    pub blob: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotResponse {
    fn default() -> &'a SnapshotResponse {
        <SnapshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotResponse {
    pub fn new() -> SnapshotResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // uint64 remaining_bytes = 2;


    pub fn get_remaining_bytes(&self) -> u64 {
        self.remaining_bytes
    }
    pub fn clear_remaining_bytes(&mut self) {
        self.remaining_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_remaining_bytes(&mut self, v: u64) {
        self.remaining_bytes = v;
    }

    // bytes blob = 3;


    pub fn get_blob(&self) -> &[u8] {
        &self.blob
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blob
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blob, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshotResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining_bytes = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.remaining_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remaining_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.blob.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.blob);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.remaining_bytes != 0 {
            os.write_uint64(2, self.remaining_bytes)?;
        }
        if !self.blob.is_empty() {
            os.write_bytes(3, &self.blob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotResponse {
        SnapshotResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &SnapshotResponse| { &m.header },
                |m: &mut SnapshotResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remaining_bytes",
                |m: &SnapshotResponse| { &m.remaining_bytes },
                |m: &mut SnapshotResponse| { &mut m.remaining_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blob",
                |m: &SnapshotResponse| { &m.blob },
                |m: &mut SnapshotResponse| { &mut m.blob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotResponse>(
                "SnapshotResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotResponse {
        static instance: ::protobuf::rt::LazyV2<SnapshotResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotResponse::new)
    }
}

impl ::protobuf::Clear for SnapshotResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.remaining_bytes = 0;
        self.blob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchRequest {
    // message oneof groups
    pub request_union: ::std::option::Option<WatchRequest_oneof_request_union>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchRequest {
    fn default() -> &'a WatchRequest {
        <WatchRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum WatchRequest_oneof_request_union {
    create_request(WatchCreateRequest),
    cancel_request(WatchCancelRequest),
}

impl WatchRequest {
    pub fn new() -> WatchRequest {
        ::std::default::Default::default()
    }

    // .etcdserverpb.WatchCreateRequest create_request = 1;


    pub fn get_create_request(&self) -> &WatchCreateRequest {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(ref v)) => v,
            _ => <WatchCreateRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create_request(&mut self) {
        self.request_union = ::std::option::Option::None;
    }

    pub fn has_create_request(&self) -> bool {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_request(&mut self, v: WatchCreateRequest) {
        self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_request(&mut self) -> &mut WatchCreateRequest {
        if let ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(_)) = self.request_union {
        } else {
            self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(WatchCreateRequest::new()));
        }
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_request(&mut self) -> WatchCreateRequest {
        if self.has_create_request() {
            match self.request_union.take() {
                ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WatchCreateRequest::new()
        }
    }

    // .etcdserverpb.WatchCancelRequest cancel_request = 2;


    pub fn get_cancel_request(&self) -> &WatchCancelRequest {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(ref v)) => v,
            _ => <WatchCancelRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cancel_request(&mut self) {
        self.request_union = ::std::option::Option::None;
    }

    pub fn has_cancel_request(&self) -> bool {
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cancel_request(&mut self, v: WatchCancelRequest) {
        self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cancel_request(&mut self) -> &mut WatchCancelRequest {
        if let ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(_)) = self.request_union {
        } else {
            self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(WatchCancelRequest::new()));
        }
        match self.request_union {
            ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cancel_request(&mut self) -> WatchCancelRequest {
        if self.has_cancel_request() {
            match self.request_union.take() {
                ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WatchCancelRequest::new()
        }
    }
}

impl ::protobuf::Message for WatchRequest {
    fn is_initialized(&self) -> bool {
        if let Some(WatchRequest_oneof_request_union::create_request(ref v)) = self.request_union {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(WatchRequest_oneof_request_union::cancel_request(ref v)) = self.request_union {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::create_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request_union = ::std::option::Option::Some(WatchRequest_oneof_request_union::cancel_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request_union {
            match v {
                &WatchRequest_oneof_request_union::create_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &WatchRequest_oneof_request_union::cancel_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request_union {
            match v {
                &WatchRequest_oneof_request_union::create_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &WatchRequest_oneof_request_union::cancel_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchRequest {
        WatchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WatchCreateRequest>(
                "create_request",
                WatchRequest::has_create_request,
                WatchRequest::get_create_request,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WatchCancelRequest>(
                "cancel_request",
                WatchRequest::has_cancel_request,
                WatchRequest::get_cancel_request,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchRequest>(
                "WatchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchRequest {
        static instance: ::protobuf::rt::LazyV2<WatchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchRequest::new)
    }
}

impl ::protobuf::Clear for WatchRequest {
    fn clear(&mut self) {
        self.request_union = ::std::option::Option::None;
        self.request_union = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchCreateRequest {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub range_end: ::std::vec::Vec<u8>,
    pub start_revision: i64,
    pub progress_notify: bool,
    pub filters: ::std::vec::Vec<WatchCreateRequest_FilterType>,
    pub prev_kv: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchCreateRequest {
    fn default() -> &'a WatchCreateRequest {
        <WatchCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl WatchCreateRequest {
    pub fn new() -> WatchCreateRequest {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes range_end = 2;


    pub fn get_range_end(&self) -> &[u8] {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.range_end, ::std::vec::Vec::new())
    }

    // int64 start_revision = 3;


    pub fn get_start_revision(&self) -> i64 {
        self.start_revision
    }
    pub fn clear_start_revision(&mut self) {
        self.start_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_revision(&mut self, v: i64) {
        self.start_revision = v;
    }

    // bool progress_notify = 4;


    pub fn get_progress_notify(&self) -> bool {
        self.progress_notify
    }
    pub fn clear_progress_notify(&mut self) {
        self.progress_notify = false;
    }

    // Param is passed by value, moved
    pub fn set_progress_notify(&mut self, v: bool) {
        self.progress_notify = v;
    }

    // repeated .etcdserverpb.WatchCreateRequest.FilterType filters = 5;


    pub fn get_filters(&self) -> &[WatchCreateRequest_FilterType] {
        &self.filters
    }
    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::std::vec::Vec<WatchCreateRequest_FilterType>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::std::vec::Vec<WatchCreateRequest_FilterType> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::std::vec::Vec<WatchCreateRequest_FilterType> {
        ::std::mem::replace(&mut self.filters, ::std::vec::Vec::new())
    }

    // bool prev_kv = 6;


    pub fn get_prev_kv(&self) -> bool {
        self.prev_kv
    }
    pub fn clear_prev_kv(&mut self) {
        self.prev_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_prev_kv(&mut self, v: bool) {
        self.prev_kv = v;
    }
}

impl ::protobuf::Message for WatchCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.range_end)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_revision = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.progress_notify = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.filters, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prev_kv = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.range_end);
        }
        if self.start_revision != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.progress_notify != false {
            my_size += 2;
        }
        for value in &self.filters {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        if self.prev_kv != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_bytes(2, &self.range_end)?;
        }
        if self.start_revision != 0 {
            os.write_int64(3, self.start_revision)?;
        }
        if self.progress_notify != false {
            os.write_bool(4, self.progress_notify)?;
        }
        for v in &self.filters {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.prev_kv != false {
            os.write_bool(6, self.prev_kv)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchCreateRequest {
        WatchCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &WatchCreateRequest| { &m.key },
                |m: &mut WatchCreateRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "range_end",
                |m: &WatchCreateRequest| { &m.range_end },
                |m: &mut WatchCreateRequest| { &mut m.range_end },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_revision",
                |m: &WatchCreateRequest| { &m.start_revision },
                |m: &mut WatchCreateRequest| { &mut m.start_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "progress_notify",
                |m: &WatchCreateRequest| { &m.progress_notify },
                |m: &mut WatchCreateRequest| { &mut m.progress_notify },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WatchCreateRequest_FilterType>>(
                "filters",
                |m: &WatchCreateRequest| { &m.filters },
                |m: &mut WatchCreateRequest| { &mut m.filters },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prev_kv",
                |m: &WatchCreateRequest| { &m.prev_kv },
                |m: &mut WatchCreateRequest| { &mut m.prev_kv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchCreateRequest>(
                "WatchCreateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchCreateRequest {
        static instance: ::protobuf::rt::LazyV2<WatchCreateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchCreateRequest::new)
    }
}

impl ::protobuf::Clear for WatchCreateRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.range_end.clear();
        self.start_revision = 0;
        self.progress_notify = false;
        self.filters.clear();
        self.prev_kv = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WatchCreateRequest_FilterType {
    NOPUT = 0,
    NODELETE = 1,
}

impl ::protobuf::ProtobufEnum for WatchCreateRequest_FilterType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WatchCreateRequest_FilterType> {
        match value {
            0 => ::std::option::Option::Some(WatchCreateRequest_FilterType::NOPUT),
            1 => ::std::option::Option::Some(WatchCreateRequest_FilterType::NODELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WatchCreateRequest_FilterType] = &[
            WatchCreateRequest_FilterType::NOPUT,
            WatchCreateRequest_FilterType::NODELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WatchCreateRequest_FilterType>("WatchCreateRequest.FilterType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WatchCreateRequest_FilterType {
}

impl ::std::default::Default for WatchCreateRequest_FilterType {
    fn default() -> Self {
        WatchCreateRequest_FilterType::NOPUT
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchCreateRequest_FilterType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchCancelRequest {
    // message fields
    pub watch_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchCancelRequest {
    fn default() -> &'a WatchCancelRequest {
        <WatchCancelRequest as ::protobuf::Message>::default_instance()
    }
}

impl WatchCancelRequest {
    pub fn new() -> WatchCancelRequest {
        ::std::default::Default::default()
    }

    // int64 watch_id = 1;


    pub fn get_watch_id(&self) -> i64 {
        self.watch_id
    }
    pub fn clear_watch_id(&mut self) {
        self.watch_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_watch_id(&mut self, v: i64) {
        self.watch_id = v;
    }
}

impl ::protobuf::Message for WatchCancelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.watch_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.watch_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.watch_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.watch_id != 0 {
            os.write_int64(1, self.watch_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchCancelRequest {
        WatchCancelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "watch_id",
                |m: &WatchCancelRequest| { &m.watch_id },
                |m: &mut WatchCancelRequest| { &mut m.watch_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchCancelRequest>(
                "WatchCancelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchCancelRequest {
        static instance: ::protobuf::rt::LazyV2<WatchCancelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchCancelRequest::new)
    }
}

impl ::protobuf::Clear for WatchCancelRequest {
    fn clear(&mut self) {
        self.watch_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchCancelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub watch_id: i64,
    pub created: bool,
    pub canceled: bool,
    pub compact_revision: i64,
    pub cancel_reason: ::std::string::String,
    pub events: ::protobuf::RepeatedField<super::kv::Event>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchResponse {
    fn default() -> &'a WatchResponse {
        <WatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl WatchResponse {
    pub fn new() -> WatchResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 watch_id = 2;


    pub fn get_watch_id(&self) -> i64 {
        self.watch_id
    }
    pub fn clear_watch_id(&mut self) {
        self.watch_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_watch_id(&mut self, v: i64) {
        self.watch_id = v;
    }

    // bool created = 3;


    pub fn get_created(&self) -> bool {
        self.created
    }
    pub fn clear_created(&mut self) {
        self.created = false;
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: bool) {
        self.created = v;
    }

    // bool canceled = 4;


    pub fn get_canceled(&self) -> bool {
        self.canceled
    }
    pub fn clear_canceled(&mut self) {
        self.canceled = false;
    }

    // Param is passed by value, moved
    pub fn set_canceled(&mut self, v: bool) {
        self.canceled = v;
    }

    // int64 compact_revision = 5;


    pub fn get_compact_revision(&self) -> i64 {
        self.compact_revision
    }
    pub fn clear_compact_revision(&mut self) {
        self.compact_revision = 0;
    }

    // Param is passed by value, moved
    pub fn set_compact_revision(&mut self, v: i64) {
        self.compact_revision = v;
    }

    // string cancel_reason = 6;


    pub fn get_cancel_reason(&self) -> &str {
        &self.cancel_reason
    }
    pub fn clear_cancel_reason(&mut self) {
        self.cancel_reason.clear();
    }

    // Param is passed by value, moved
    pub fn set_cancel_reason(&mut self, v: ::std::string::String) {
        self.cancel_reason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cancel_reason(&mut self) -> &mut ::std::string::String {
        &mut self.cancel_reason
    }

    // Take field
    pub fn take_cancel_reason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cancel_reason, ::std::string::String::new())
    }

    // repeated .mvccpb.Event events = 11;


    pub fn get_events(&self) -> &[super::kv::Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<super::kv::Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<super::kv::Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<super::kv::Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WatchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.watch_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.created = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.canceled = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compact_revision = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cancel_reason)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.watch_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.watch_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.created != false {
            my_size += 2;
        }
        if self.canceled != false {
            my_size += 2;
        }
        if self.compact_revision != 0 {
            my_size += ::protobuf::rt::value_size(5, self.compact_revision, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cancel_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cancel_reason);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.watch_id != 0 {
            os.write_int64(2, self.watch_id)?;
        }
        if self.created != false {
            os.write_bool(3, self.created)?;
        }
        if self.canceled != false {
            os.write_bool(4, self.canceled)?;
        }
        if self.compact_revision != 0 {
            os.write_int64(5, self.compact_revision)?;
        }
        if !self.cancel_reason.is_empty() {
            os.write_string(6, &self.cancel_reason)?;
        }
        for v in &self.events {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchResponse {
        WatchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &WatchResponse| { &m.header },
                |m: &mut WatchResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "watch_id",
                |m: &WatchResponse| { &m.watch_id },
                |m: &mut WatchResponse| { &mut m.watch_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "created",
                |m: &WatchResponse| { &m.created },
                |m: &mut WatchResponse| { &mut m.created },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "canceled",
                |m: &WatchResponse| { &m.canceled },
                |m: &mut WatchResponse| { &mut m.canceled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compact_revision",
                |m: &WatchResponse| { &m.compact_revision },
                |m: &mut WatchResponse| { &mut m.compact_revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cancel_reason",
                |m: &WatchResponse| { &m.cancel_reason },
                |m: &mut WatchResponse| { &mut m.cancel_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::kv::Event>>(
                "events",
                |m: &WatchResponse| { &m.events },
                |m: &mut WatchResponse| { &mut m.events },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchResponse>(
                "WatchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchResponse {
        static instance: ::protobuf::rt::LazyV2<WatchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchResponse::new)
    }
}

impl ::protobuf::Clear for WatchResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.watch_id = 0;
        self.created = false;
        self.canceled = false;
        self.compact_revision = 0;
        self.cancel_reason.clear();
        self.events.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseGrantRequest {
    // message fields
    pub TTL: i64,
    pub ID: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseGrantRequest {
    fn default() -> &'a LeaseGrantRequest {
        <LeaseGrantRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseGrantRequest {
    pub fn new() -> LeaseGrantRequest {
        ::std::default::Default::default()
    }

    // int64 TTL = 1;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for LeaseGrantRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(1, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.TTL != 0 {
            os.write_int64(1, self.TTL)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseGrantRequest {
        LeaseGrantRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TTL",
                |m: &LeaseGrantRequest| { &m.TTL },
                |m: &mut LeaseGrantRequest| { &mut m.TTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ID",
                |m: &LeaseGrantRequest| { &m.ID },
                |m: &mut LeaseGrantRequest| { &mut m.ID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseGrantRequest>(
                "LeaseGrantRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseGrantRequest {
        static instance: ::protobuf::rt::LazyV2<LeaseGrantRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseGrantRequest::new)
    }
}

impl ::protobuf::Clear for LeaseGrantRequest {
    fn clear(&mut self) {
        self.TTL = 0;
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseGrantRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseGrantRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseGrantResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub ID: i64,
    pub TTL: i64,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseGrantResponse {
    fn default() -> &'a LeaseGrantResponse {
        <LeaseGrantResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseGrantResponse {
    pub fn new() -> LeaseGrantResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // int64 TTL = 3;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }

    // string error = 4;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LeaseGrantResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(3, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        if self.TTL != 0 {
            os.write_int64(3, self.TTL)?;
        }
        if !self.error.is_empty() {
            os.write_string(4, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseGrantResponse {
        LeaseGrantResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &LeaseGrantResponse| { &m.header },
                |m: &mut LeaseGrantResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ID",
                |m: &LeaseGrantResponse| { &m.ID },
                |m: &mut LeaseGrantResponse| { &mut m.ID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TTL",
                |m: &LeaseGrantResponse| { &m.TTL },
                |m: &mut LeaseGrantResponse| { &mut m.TTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &LeaseGrantResponse| { &m.error },
                |m: &mut LeaseGrantResponse| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseGrantResponse>(
                "LeaseGrantResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseGrantResponse {
        static instance: ::protobuf::rt::LazyV2<LeaseGrantResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseGrantResponse::new)
    }
}

impl ::protobuf::Clear for LeaseGrantResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.ID = 0;
        self.TTL = 0;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseGrantResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseGrantResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseRevokeRequest {
    // message fields
    pub ID: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseRevokeRequest {
    fn default() -> &'a LeaseRevokeRequest {
        <LeaseRevokeRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseRevokeRequest {
    pub fn new() -> LeaseRevokeRequest {
        ::std::default::Default::default()
    }

    // int64 ID = 1;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for LeaseRevokeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_int64(1, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseRevokeRequest {
        LeaseRevokeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ID",
                |m: &LeaseRevokeRequest| { &m.ID },
                |m: &mut LeaseRevokeRequest| { &mut m.ID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseRevokeRequest>(
                "LeaseRevokeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseRevokeRequest {
        static instance: ::protobuf::rt::LazyV2<LeaseRevokeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseRevokeRequest::new)
    }
}

impl ::protobuf::Clear for LeaseRevokeRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseRevokeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseRevokeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseRevokeResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseRevokeResponse {
    fn default() -> &'a LeaseRevokeResponse {
        <LeaseRevokeResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseRevokeResponse {
    pub fn new() -> LeaseRevokeResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for LeaseRevokeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseRevokeResponse {
        LeaseRevokeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &LeaseRevokeResponse| { &m.header },
                |m: &mut LeaseRevokeResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseRevokeResponse>(
                "LeaseRevokeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseRevokeResponse {
        static instance: ::protobuf::rt::LazyV2<LeaseRevokeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseRevokeResponse::new)
    }
}

impl ::protobuf::Clear for LeaseRevokeResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseRevokeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseRevokeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseKeepAliveRequest {
    // message fields
    pub ID: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseKeepAliveRequest {
    fn default() -> &'a LeaseKeepAliveRequest {
        <LeaseKeepAliveRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseKeepAliveRequest {
    pub fn new() -> LeaseKeepAliveRequest {
        ::std::default::Default::default()
    }

    // int64 ID = 1;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for LeaseKeepAliveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_int64(1, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseKeepAliveRequest {
        LeaseKeepAliveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ID",
                |m: &LeaseKeepAliveRequest| { &m.ID },
                |m: &mut LeaseKeepAliveRequest| { &mut m.ID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseKeepAliveRequest>(
                "LeaseKeepAliveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseKeepAliveRequest {
        static instance: ::protobuf::rt::LazyV2<LeaseKeepAliveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseKeepAliveRequest::new)
    }
}

impl ::protobuf::Clear for LeaseKeepAliveRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseKeepAliveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseKeepAliveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseKeepAliveResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub ID: i64,
    pub TTL: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseKeepAliveResponse {
    fn default() -> &'a LeaseKeepAliveResponse {
        <LeaseKeepAliveResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseKeepAliveResponse {
    pub fn new() -> LeaseKeepAliveResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // int64 TTL = 3;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }
}

impl ::protobuf::Message for LeaseKeepAliveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(3, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        if self.TTL != 0 {
            os.write_int64(3, self.TTL)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseKeepAliveResponse {
        LeaseKeepAliveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &LeaseKeepAliveResponse| { &m.header },
                |m: &mut LeaseKeepAliveResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ID",
                |m: &LeaseKeepAliveResponse| { &m.ID },
                |m: &mut LeaseKeepAliveResponse| { &mut m.ID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TTL",
                |m: &LeaseKeepAliveResponse| { &m.TTL },
                |m: &mut LeaseKeepAliveResponse| { &mut m.TTL },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseKeepAliveResponse>(
                "LeaseKeepAliveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseKeepAliveResponse {
        static instance: ::protobuf::rt::LazyV2<LeaseKeepAliveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseKeepAliveResponse::new)
    }
}

impl ::protobuf::Clear for LeaseKeepAliveResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.ID = 0;
        self.TTL = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseKeepAliveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseKeepAliveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseTimeToLiveRequest {
    // message fields
    pub ID: i64,
    pub keys: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseTimeToLiveRequest {
    fn default() -> &'a LeaseTimeToLiveRequest {
        <LeaseTimeToLiveRequest as ::protobuf::Message>::default_instance()
    }
}

impl LeaseTimeToLiveRequest {
    pub fn new() -> LeaseTimeToLiveRequest {
        ::std::default::Default::default()
    }

    // int64 ID = 1;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // bool keys = 2;


    pub fn get_keys(&self) -> bool {
        self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys = false;
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: bool) {
        self.keys = v;
    }
}

impl ::protobuf::Message for LeaseTimeToLiveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.keys = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.keys != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_int64(1, self.ID)?;
        }
        if self.keys != false {
            os.write_bool(2, self.keys)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseTimeToLiveRequest {
        LeaseTimeToLiveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ID",
                |m: &LeaseTimeToLiveRequest| { &m.ID },
                |m: &mut LeaseTimeToLiveRequest| { &mut m.ID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "keys",
                |m: &LeaseTimeToLiveRequest| { &m.keys },
                |m: &mut LeaseTimeToLiveRequest| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseTimeToLiveRequest>(
                "LeaseTimeToLiveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseTimeToLiveRequest {
        static instance: ::protobuf::rt::LazyV2<LeaseTimeToLiveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseTimeToLiveRequest::new)
    }
}

impl ::protobuf::Clear for LeaseTimeToLiveRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.keys = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseTimeToLiveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseTimeToLiveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LeaseTimeToLiveResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub ID: i64,
    pub TTL: i64,
    pub grantedTTL: i64,
    pub keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LeaseTimeToLiveResponse {
    fn default() -> &'a LeaseTimeToLiveResponse {
        <LeaseTimeToLiveResponse as ::protobuf::Message>::default_instance()
    }
}

impl LeaseTimeToLiveResponse {
    pub fn new() -> LeaseTimeToLiveResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // int64 ID = 2;


    pub fn get_ID(&self) -> i64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: i64) {
        self.ID = v;
    }

    // int64 TTL = 3;


    pub fn get_TTL(&self) -> i64 {
        self.TTL
    }
    pub fn clear_TTL(&mut self) {
        self.TTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_TTL(&mut self, v: i64) {
        self.TTL = v;
    }

    // int64 grantedTTL = 4;


    pub fn get_grantedTTL(&self) -> i64 {
        self.grantedTTL
    }
    pub fn clear_grantedTTL(&mut self) {
        self.grantedTTL = 0;
    }

    // Param is passed by value, moved
    pub fn set_grantedTTL(&mut self, v: i64) {
        self.grantedTTL = v;
    }

    // repeated bytes keys = 5;


    pub fn get_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LeaseTimeToLiveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ID = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TTL = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.grantedTTL = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TTL != 0 {
            my_size += ::protobuf::rt::value_size(3, self.TTL, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.grantedTTL != 0 {
            my_size += ::protobuf::rt::value_size(4, self.grantedTTL, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ID != 0 {
            os.write_int64(2, self.ID)?;
        }
        if self.TTL != 0 {
            os.write_int64(3, self.TTL)?;
        }
        if self.grantedTTL != 0 {
            os.write_int64(4, self.grantedTTL)?;
        }
        for v in &self.keys {
            os.write_bytes(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LeaseTimeToLiveResponse {
        LeaseTimeToLiveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &LeaseTimeToLiveResponse| { &m.header },
                |m: &mut LeaseTimeToLiveResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ID",
                |m: &LeaseTimeToLiveResponse| { &m.ID },
                |m: &mut LeaseTimeToLiveResponse| { &mut m.ID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TTL",
                |m: &LeaseTimeToLiveResponse| { &m.TTL },
                |m: &mut LeaseTimeToLiveResponse| { &mut m.TTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "grantedTTL",
                |m: &LeaseTimeToLiveResponse| { &m.grantedTTL },
                |m: &mut LeaseTimeToLiveResponse| { &mut m.grantedTTL },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "keys",
                |m: &LeaseTimeToLiveResponse| { &m.keys },
                |m: &mut LeaseTimeToLiveResponse| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LeaseTimeToLiveResponse>(
                "LeaseTimeToLiveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LeaseTimeToLiveResponse {
        static instance: ::protobuf::rt::LazyV2<LeaseTimeToLiveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LeaseTimeToLiveResponse::new)
    }
}

impl ::protobuf::Clear for LeaseTimeToLiveResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.ID = 0;
        self.TTL = 0;
        self.grantedTTL = 0;
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LeaseTimeToLiveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LeaseTimeToLiveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Member {
    // message fields
    pub ID: u64,
    pub name: ::std::string::String,
    pub peerURLs: ::protobuf::RepeatedField<::std::string::String>,
    pub clientURLs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Member {
    fn default() -> &'a Member {
        <Member as ::protobuf::Message>::default_instance()
    }
}

impl Member {
    pub fn new() -> Member {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_ID(&self) -> u64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: u64) {
        self.ID = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string peerURLs = 3;


    pub fn get_peerURLs(&self) -> &[::std::string::String] {
        &self.peerURLs
    }
    pub fn clear_peerURLs(&mut self) {
        self.peerURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerURLs
    }

    // Take field
    pub fn take_peerURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerURLs, ::protobuf::RepeatedField::new())
    }

    // repeated string clientURLs = 4;


    pub fn get_clientURLs(&self) -> &[::std::string::String] {
        &self.clientURLs
    }
    pub fn clear_clientURLs(&mut self) {
        self.clientURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_clientURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.clientURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clientURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.clientURLs
    }

    // Take field
    pub fn take_clientURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.clientURLs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerURLs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.clientURLs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.peerURLs {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.clientURLs {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.peerURLs {
            os.write_string(3, &v)?;
        };
        for v in &self.clientURLs {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Member {
        Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ID",
                |m: &Member| { &m.ID },
                |m: &mut Member| { &mut m.ID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Member| { &m.name },
                |m: &mut Member| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerURLs",
                |m: &Member| { &m.peerURLs },
                |m: &mut Member| { &mut m.peerURLs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientURLs",
                |m: &Member| { &m.clientURLs },
                |m: &mut Member| { &mut m.clientURLs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Member>(
                "Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Member {
        static instance: ::protobuf::rt::LazyV2<Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Member::new)
    }
}

impl ::protobuf::Clear for Member {
    fn clear(&mut self) {
        self.ID = 0;
        self.name.clear();
        self.peerURLs.clear();
        self.clientURLs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberAddRequest {
    // message fields
    pub peerURLs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberAddRequest {
    fn default() -> &'a MemberAddRequest {
        <MemberAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberAddRequest {
    pub fn new() -> MemberAddRequest {
        ::std::default::Default::default()
    }

    // repeated string peerURLs = 1;


    pub fn get_peerURLs(&self) -> &[::std::string::String] {
        &self.peerURLs
    }
    pub fn clear_peerURLs(&mut self) {
        self.peerURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerURLs
    }

    // Take field
    pub fn take_peerURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerURLs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerURLs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peerURLs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peerURLs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberAddRequest {
        MemberAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerURLs",
                |m: &MemberAddRequest| { &m.peerURLs },
                |m: &mut MemberAddRequest| { &mut m.peerURLs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberAddRequest>(
                "MemberAddRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberAddRequest {
        static instance: ::protobuf::rt::LazyV2<MemberAddRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberAddRequest::new)
    }
}

impl ::protobuf::Clear for MemberAddRequest {
    fn clear(&mut self) {
        self.peerURLs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberAddResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub member: ::protobuf::SingularPtrField<Member>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberAddResponse {
    fn default() -> &'a MemberAddResponse {
        <MemberAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberAddResponse {
    pub fn new() -> MemberAddResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // .etcdserverpb.Member member = 2;


    pub fn get_member(&self) -> &Member {
        self.member.as_ref().unwrap_or_else(|| <Member as ::protobuf::Message>::default_instance())
    }
    pub fn clear_member(&mut self) {
        self.member.clear();
    }

    pub fn has_member(&self) -> bool {
        self.member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: Member) {
        self.member = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member(&mut self) -> &mut Member {
        if self.member.is_none() {
            self.member.set_default();
        }
        self.member.as_mut().unwrap()
    }

    // Take field
    pub fn take_member(&mut self) -> Member {
        self.member.take().unwrap_or_else(|| Member::new())
    }

    // repeated .etcdserverpb.Member members = 3;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.member {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.member)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.member.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberAddResponse {
        MemberAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &MemberAddResponse| { &m.header },
                |m: &mut MemberAddResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "member",
                |m: &MemberAddResponse| { &m.member },
                |m: &mut MemberAddResponse| { &mut m.member },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "members",
                |m: &MemberAddResponse| { &m.members },
                |m: &mut MemberAddResponse| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberAddResponse>(
                "MemberAddResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberAddResponse {
        static instance: ::protobuf::rt::LazyV2<MemberAddResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberAddResponse::new)
    }
}

impl ::protobuf::Clear for MemberAddResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.member.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberRemoveRequest {
    // message fields
    pub ID: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberRemoveRequest {
    fn default() -> &'a MemberRemoveRequest {
        <MemberRemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberRemoveRequest {
    pub fn new() -> MemberRemoveRequest {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_ID(&self) -> u64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: u64) {
        self.ID = v;
    }
}

impl ::protobuf::Message for MemberRemoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberRemoveRequest {
        MemberRemoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ID",
                |m: &MemberRemoveRequest| { &m.ID },
                |m: &mut MemberRemoveRequest| { &mut m.ID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberRemoveRequest>(
                "MemberRemoveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberRemoveRequest {
        static instance: ::protobuf::rt::LazyV2<MemberRemoveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberRemoveRequest::new)
    }
}

impl ::protobuf::Clear for MemberRemoveRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberRemoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberRemoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberRemoveResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberRemoveResponse {
    fn default() -> &'a MemberRemoveResponse {
        <MemberRemoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberRemoveResponse {
    pub fn new() -> MemberRemoveResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.Member members = 2;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberRemoveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberRemoveResponse {
        MemberRemoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &MemberRemoveResponse| { &m.header },
                |m: &mut MemberRemoveResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "members",
                |m: &MemberRemoveResponse| { &m.members },
                |m: &mut MemberRemoveResponse| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberRemoveResponse>(
                "MemberRemoveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberRemoveResponse {
        static instance: ::protobuf::rt::LazyV2<MemberRemoveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberRemoveResponse::new)
    }
}

impl ::protobuf::Clear for MemberRemoveResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberRemoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberRemoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberUpdateRequest {
    // message fields
    pub ID: u64,
    pub peerURLs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberUpdateRequest {
    fn default() -> &'a MemberUpdateRequest {
        <MemberUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberUpdateRequest {
    pub fn new() -> MemberUpdateRequest {
        ::std::default::Default::default()
    }

    // uint64 ID = 1;


    pub fn get_ID(&self) -> u64 {
        self.ID
    }
    pub fn clear_ID(&mut self) {
        self.ID = 0;
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: u64) {
        self.ID = v;
    }

    // repeated string peerURLs = 2;


    pub fn get_peerURLs(&self) -> &[::std::string::String] {
        &self.peerURLs
    }
    pub fn clear_peerURLs(&mut self) {
        self.peerURLs.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerURLs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerURLs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerURLs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerURLs
    }

    // Take field
    pub fn take_peerURLs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerURLs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberUpdateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerURLs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ID, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.peerURLs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        for v in &self.peerURLs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberUpdateRequest {
        MemberUpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ID",
                |m: &MemberUpdateRequest| { &m.ID },
                |m: &mut MemberUpdateRequest| { &mut m.ID },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerURLs",
                |m: &MemberUpdateRequest| { &m.peerURLs },
                |m: &mut MemberUpdateRequest| { &mut m.peerURLs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberUpdateRequest>(
                "MemberUpdateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberUpdateRequest {
        static instance: ::protobuf::rt::LazyV2<MemberUpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberUpdateRequest::new)
    }
}

impl ::protobuf::Clear for MemberUpdateRequest {
    fn clear(&mut self) {
        self.ID = 0;
        self.peerURLs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberUpdateResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberUpdateResponse {
    fn default() -> &'a MemberUpdateResponse {
        <MemberUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberUpdateResponse {
    pub fn new() -> MemberUpdateResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.Member members = 2;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberUpdateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberUpdateResponse {
        MemberUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &MemberUpdateResponse| { &m.header },
                |m: &mut MemberUpdateResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "members",
                |m: &MemberUpdateResponse| { &m.members },
                |m: &mut MemberUpdateResponse| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberUpdateResponse>(
                "MemberUpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberUpdateResponse {
        static instance: ::protobuf::rt::LazyV2<MemberUpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberUpdateResponse::new)
    }
}

impl ::protobuf::Clear for MemberUpdateResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberListRequest {
    fn default() -> &'a MemberListRequest {
        <MemberListRequest as ::protobuf::Message>::default_instance()
    }
}

impl MemberListRequest {
    pub fn new() -> MemberListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MemberListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberListRequest {
        MemberListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberListRequest>(
                "MemberListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberListRequest {
        static instance: ::protobuf::rt::LazyV2<MemberListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberListRequest::new)
    }
}

impl ::protobuf::Clear for MemberListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MemberListResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub members: ::protobuf::RepeatedField<Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MemberListResponse {
    fn default() -> &'a MemberListResponse {
        <MemberListResponse as ::protobuf::Message>::default_instance()
    }
}

impl MemberListResponse {
    pub fn new() -> MemberListResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.Member members = 2;


    pub fn get_members(&self) -> &[Member] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MemberListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MemberListResponse {
        MemberListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &MemberListResponse| { &m.header },
                |m: &mut MemberListResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Member>>(
                "members",
                |m: &MemberListResponse| { &m.members },
                |m: &mut MemberListResponse| { &mut m.members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MemberListResponse>(
                "MemberListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MemberListResponse {
        static instance: ::protobuf::rt::LazyV2<MemberListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MemberListResponse::new)
    }
}

impl ::protobuf::Clear for MemberListResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MemberListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MemberListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefragmentRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefragmentRequest {
    fn default() -> &'a DefragmentRequest {
        <DefragmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl DefragmentRequest {
    pub fn new() -> DefragmentRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DefragmentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefragmentRequest {
        DefragmentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefragmentRequest>(
                "DefragmentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DefragmentRequest {
        static instance: ::protobuf::rt::LazyV2<DefragmentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DefragmentRequest::new)
    }
}

impl ::protobuf::Clear for DefragmentRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefragmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefragmentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefragmentResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefragmentResponse {
    fn default() -> &'a DefragmentResponse {
        <DefragmentResponse as ::protobuf::Message>::default_instance()
    }
}

impl DefragmentResponse {
    pub fn new() -> DefragmentResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for DefragmentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefragmentResponse {
        DefragmentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &DefragmentResponse| { &m.header },
                |m: &mut DefragmentResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefragmentResponse>(
                "DefragmentResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DefragmentResponse {
        static instance: ::protobuf::rt::LazyV2<DefragmentResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DefragmentResponse::new)
    }
}

impl ::protobuf::Clear for DefragmentResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefragmentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefragmentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveLeaderRequest {
    // message fields
    pub targetID: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveLeaderRequest {
    fn default() -> &'a MoveLeaderRequest {
        <MoveLeaderRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoveLeaderRequest {
    pub fn new() -> MoveLeaderRequest {
        ::std::default::Default::default()
    }

    // uint64 targetID = 1;


    pub fn get_targetID(&self) -> u64 {
        self.targetID
    }
    pub fn clear_targetID(&mut self) {
        self.targetID = 0;
    }

    // Param is passed by value, moved
    pub fn set_targetID(&mut self, v: u64) {
        self.targetID = v;
    }
}

impl ::protobuf::Message for MoveLeaderRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.targetID = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.targetID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.targetID, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.targetID != 0 {
            os.write_uint64(1, self.targetID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveLeaderRequest {
        MoveLeaderRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "targetID",
                |m: &MoveLeaderRequest| { &m.targetID },
                |m: &mut MoveLeaderRequest| { &mut m.targetID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveLeaderRequest>(
                "MoveLeaderRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveLeaderRequest {
        static instance: ::protobuf::rt::LazyV2<MoveLeaderRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveLeaderRequest::new)
    }
}

impl ::protobuf::Clear for MoveLeaderRequest {
    fn clear(&mut self) {
        self.targetID = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveLeaderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveLeaderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveLeaderResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveLeaderResponse {
    fn default() -> &'a MoveLeaderResponse {
        <MoveLeaderResponse as ::protobuf::Message>::default_instance()
    }
}

impl MoveLeaderResponse {
    pub fn new() -> MoveLeaderResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for MoveLeaderResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveLeaderResponse {
        MoveLeaderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &MoveLeaderResponse| { &m.header },
                |m: &mut MoveLeaderResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoveLeaderResponse>(
                "MoveLeaderResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoveLeaderResponse {
        static instance: ::protobuf::rt::LazyV2<MoveLeaderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoveLeaderResponse::new)
    }
}

impl ::protobuf::Clear for MoveLeaderResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveLeaderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveLeaderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlarmRequest {
    // message fields
    pub action: AlarmRequest_AlarmAction,
    pub memberID: u64,
    pub alarm: AlarmType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlarmRequest {
    fn default() -> &'a AlarmRequest {
        <AlarmRequest as ::protobuf::Message>::default_instance()
    }
}

impl AlarmRequest {
    pub fn new() -> AlarmRequest {
        ::std::default::Default::default()
    }

    // .etcdserverpb.AlarmRequest.AlarmAction action = 1;


    pub fn get_action(&self) -> AlarmRequest_AlarmAction {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = AlarmRequest_AlarmAction::GET;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: AlarmRequest_AlarmAction) {
        self.action = v;
    }

    // uint64 memberID = 2;


    pub fn get_memberID(&self) -> u64 {
        self.memberID
    }
    pub fn clear_memberID(&mut self) {
        self.memberID = 0;
    }

    // Param is passed by value, moved
    pub fn set_memberID(&mut self, v: u64) {
        self.memberID = v;
    }

    // .etcdserverpb.AlarmType alarm = 3;


    pub fn get_alarm(&self) -> AlarmType {
        self.alarm
    }
    pub fn clear_alarm(&mut self) {
        self.alarm = AlarmType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_alarm(&mut self, v: AlarmType) {
        self.alarm = v;
    }
}

impl ::protobuf::Message for AlarmRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.memberID = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.alarm, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != AlarmRequest_AlarmAction::GET {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        if self.memberID != 0 {
            my_size += ::protobuf::rt::value_size(2, self.memberID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.alarm != AlarmType::NONE {
            my_size += ::protobuf::rt::enum_size(3, self.alarm);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action != AlarmRequest_AlarmAction::GET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if self.memberID != 0 {
            os.write_uint64(2, self.memberID)?;
        }
        if self.alarm != AlarmType::NONE {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.alarm))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlarmRequest {
        AlarmRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AlarmRequest_AlarmAction>>(
                "action",
                |m: &AlarmRequest| { &m.action },
                |m: &mut AlarmRequest| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "memberID",
                |m: &AlarmRequest| { &m.memberID },
                |m: &mut AlarmRequest| { &mut m.memberID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AlarmType>>(
                "alarm",
                |m: &AlarmRequest| { &m.alarm },
                |m: &mut AlarmRequest| { &mut m.alarm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlarmRequest>(
                "AlarmRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlarmRequest {
        static instance: ::protobuf::rt::LazyV2<AlarmRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlarmRequest::new)
    }
}

impl ::protobuf::Clear for AlarmRequest {
    fn clear(&mut self) {
        self.action = AlarmRequest_AlarmAction::GET;
        self.memberID = 0;
        self.alarm = AlarmType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlarmRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AlarmRequest_AlarmAction {
    GET = 0,
    ACTIVATE = 1,
    DEACTIVATE = 2,
}

impl ::protobuf::ProtobufEnum for AlarmRequest_AlarmAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlarmRequest_AlarmAction> {
        match value {
            0 => ::std::option::Option::Some(AlarmRequest_AlarmAction::GET),
            1 => ::std::option::Option::Some(AlarmRequest_AlarmAction::ACTIVATE),
            2 => ::std::option::Option::Some(AlarmRequest_AlarmAction::DEACTIVATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AlarmRequest_AlarmAction] = &[
            AlarmRequest_AlarmAction::GET,
            AlarmRequest_AlarmAction::ACTIVATE,
            AlarmRequest_AlarmAction::DEACTIVATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AlarmRequest_AlarmAction>("AlarmRequest.AlarmAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AlarmRequest_AlarmAction {
}

impl ::std::default::Default for AlarmRequest_AlarmAction {
    fn default() -> Self {
        AlarmRequest_AlarmAction::GET
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmRequest_AlarmAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlarmMember {
    // message fields
    pub memberID: u64,
    pub alarm: AlarmType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlarmMember {
    fn default() -> &'a AlarmMember {
        <AlarmMember as ::protobuf::Message>::default_instance()
    }
}

impl AlarmMember {
    pub fn new() -> AlarmMember {
        ::std::default::Default::default()
    }

    // uint64 memberID = 1;


    pub fn get_memberID(&self) -> u64 {
        self.memberID
    }
    pub fn clear_memberID(&mut self) {
        self.memberID = 0;
    }

    // Param is passed by value, moved
    pub fn set_memberID(&mut self, v: u64) {
        self.memberID = v;
    }

    // .etcdserverpb.AlarmType alarm = 2;


    pub fn get_alarm(&self) -> AlarmType {
        self.alarm
    }
    pub fn clear_alarm(&mut self) {
        self.alarm = AlarmType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_alarm(&mut self, v: AlarmType) {
        self.alarm = v;
    }
}

impl ::protobuf::Message for AlarmMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.memberID = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.alarm, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.memberID != 0 {
            my_size += ::protobuf::rt::value_size(1, self.memberID, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.alarm != AlarmType::NONE {
            my_size += ::protobuf::rt::enum_size(2, self.alarm);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.memberID != 0 {
            os.write_uint64(1, self.memberID)?;
        }
        if self.alarm != AlarmType::NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.alarm))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlarmMember {
        AlarmMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "memberID",
                |m: &AlarmMember| { &m.memberID },
                |m: &mut AlarmMember| { &mut m.memberID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AlarmType>>(
                "alarm",
                |m: &AlarmMember| { &m.alarm },
                |m: &mut AlarmMember| { &mut m.alarm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlarmMember>(
                "AlarmMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlarmMember {
        static instance: ::protobuf::rt::LazyV2<AlarmMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlarmMember::new)
    }
}

impl ::protobuf::Clear for AlarmMember {
    fn clear(&mut self) {
        self.memberID = 0;
        self.alarm = AlarmType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlarmMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlarmResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub alarms: ::protobuf::RepeatedField<AlarmMember>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlarmResponse {
    fn default() -> &'a AlarmResponse {
        <AlarmResponse as ::protobuf::Message>::default_instance()
    }
}

impl AlarmResponse {
    pub fn new() -> AlarmResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .etcdserverpb.AlarmMember alarms = 2;


    pub fn get_alarms(&self) -> &[AlarmMember] {
        &self.alarms
    }
    pub fn clear_alarms(&mut self) {
        self.alarms.clear();
    }

    // Param is passed by value, moved
    pub fn set_alarms(&mut self, v: ::protobuf::RepeatedField<AlarmMember>) {
        self.alarms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alarms(&mut self) -> &mut ::protobuf::RepeatedField<AlarmMember> {
        &mut self.alarms
    }

    // Take field
    pub fn take_alarms(&mut self) -> ::protobuf::RepeatedField<AlarmMember> {
        ::std::mem::replace(&mut self.alarms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AlarmResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alarms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.alarms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.alarms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.alarms {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlarmResponse {
        AlarmResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AlarmResponse| { &m.header },
                |m: &mut AlarmResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlarmMember>>(
                "alarms",
                |m: &AlarmResponse| { &m.alarms },
                |m: &mut AlarmResponse| { &mut m.alarms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlarmResponse>(
                "AlarmResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlarmResponse {
        static instance: ::protobuf::rt::LazyV2<AlarmResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlarmResponse::new)
    }
}

impl ::protobuf::Clear for AlarmResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.alarms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlarmResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusRequest {
    fn default() -> &'a StatusRequest {
        <StatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatusRequest {
    pub fn new() -> StatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusRequest {
        StatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusRequest>(
                "StatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusRequest {
        static instance: ::protobuf::rt::LazyV2<StatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusRequest::new)
    }
}

impl ::protobuf::Clear for StatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub version: ::std::string::String,
    pub dbSize: i64,
    pub leader: u64,
    pub raftIndex: u64,
    pub raftTerm: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusResponse {
    fn default() -> &'a StatusResponse {
        <StatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatusResponse {
    pub fn new() -> StatusResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // int64 dbSize = 3;


    pub fn get_dbSize(&self) -> i64 {
        self.dbSize
    }
    pub fn clear_dbSize(&mut self) {
        self.dbSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_dbSize(&mut self, v: i64) {
        self.dbSize = v;
    }

    // uint64 leader = 4;


    pub fn get_leader(&self) -> u64 {
        self.leader
    }
    pub fn clear_leader(&mut self) {
        self.leader = 0;
    }

    // Param is passed by value, moved
    pub fn set_leader(&mut self, v: u64) {
        self.leader = v;
    }

    // uint64 raftIndex = 5;


    pub fn get_raftIndex(&self) -> u64 {
        self.raftIndex
    }
    pub fn clear_raftIndex(&mut self) {
        self.raftIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_raftIndex(&mut self, v: u64) {
        self.raftIndex = v;
    }

    // uint64 raftTerm = 6;


    pub fn get_raftTerm(&self) -> u64 {
        self.raftTerm
    }
    pub fn clear_raftTerm(&mut self) {
        self.raftTerm = 0;
    }

    // Param is passed by value, moved
    pub fn set_raftTerm(&mut self, v: u64) {
        self.raftTerm = v;
    }
}

impl ::protobuf::Message for StatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dbSize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.leader = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raftIndex = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.raftTerm = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if self.dbSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dbSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.leader != 0 {
            my_size += ::protobuf::rt::value_size(4, self.leader, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raftIndex != 0 {
            my_size += ::protobuf::rt::value_size(5, self.raftIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.raftTerm != 0 {
            my_size += ::protobuf::rt::value_size(6, self.raftTerm, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if self.dbSize != 0 {
            os.write_int64(3, self.dbSize)?;
        }
        if self.leader != 0 {
            os.write_uint64(4, self.leader)?;
        }
        if self.raftIndex != 0 {
            os.write_uint64(5, self.raftIndex)?;
        }
        if self.raftTerm != 0 {
            os.write_uint64(6, self.raftTerm)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusResponse {
        StatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &StatusResponse| { &m.header },
                |m: &mut StatusResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &StatusResponse| { &m.version },
                |m: &mut StatusResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dbSize",
                |m: &StatusResponse| { &m.dbSize },
                |m: &mut StatusResponse| { &mut m.dbSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "leader",
                |m: &StatusResponse| { &m.leader },
                |m: &mut StatusResponse| { &mut m.leader },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "raftIndex",
                |m: &StatusResponse| { &m.raftIndex },
                |m: &mut StatusResponse| { &mut m.raftIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "raftTerm",
                |m: &StatusResponse| { &m.raftTerm },
                |m: &mut StatusResponse| { &mut m.raftTerm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusResponse>(
                "StatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusResponse {
        static instance: ::protobuf::rt::LazyV2<StatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusResponse::new)
    }
}

impl ::protobuf::Clear for StatusResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.version.clear();
        self.dbSize = 0;
        self.leader = 0;
        self.raftIndex = 0;
        self.raftTerm = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthEnableRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthEnableRequest {
    fn default() -> &'a AuthEnableRequest {
        <AuthEnableRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthEnableRequest {
    pub fn new() -> AuthEnableRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthEnableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthEnableRequest {
        AuthEnableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthEnableRequest>(
                "AuthEnableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthEnableRequest {
        static instance: ::protobuf::rt::LazyV2<AuthEnableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthEnableRequest::new)
    }
}

impl ::protobuf::Clear for AuthEnableRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthEnableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthEnableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthDisableRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthDisableRequest {
    fn default() -> &'a AuthDisableRequest {
        <AuthDisableRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthDisableRequest {
    pub fn new() -> AuthDisableRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthDisableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthDisableRequest {
        AuthDisableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthDisableRequest>(
                "AuthDisableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthDisableRequest {
        static instance: ::protobuf::rt::LazyV2<AuthDisableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthDisableRequest::new)
    }
}

impl ::protobuf::Clear for AuthDisableRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthDisableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthDisableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateRequest {
    // message fields
    pub name: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateRequest {
    fn default() -> &'a AuthenticateRequest {
        <AuthenticateRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateRequest {
    pub fn new() -> AuthenticateRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthenticateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateRequest {
        AuthenticateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthenticateRequest| { &m.name },
                |m: &mut AuthenticateRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &AuthenticateRequest| { &m.password },
                |m: &mut AuthenticateRequest| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticateRequest>(
                "AuthenticateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticateRequest {
        static instance: ::protobuf::rt::LazyV2<AuthenticateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticateRequest::new)
    }
}

impl ::protobuf::Clear for AuthenticateRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserAddRequest {
    // message fields
    pub name: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserAddRequest {
    fn default() -> &'a AuthUserAddRequest {
        <AuthUserAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserAddRequest {
    pub fn new() -> AuthUserAddRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserAddRequest {
        AuthUserAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthUserAddRequest| { &m.name },
                |m: &mut AuthUserAddRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &AuthUserAddRequest| { &m.password },
                |m: &mut AuthUserAddRequest| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserAddRequest>(
                "AuthUserAddRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserAddRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUserAddRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserAddRequest::new)
    }
}

impl ::protobuf::Clear for AuthUserAddRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGetRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGetRequest {
    fn default() -> &'a AuthUserGetRequest {
        <AuthUserGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGetRequest {
    pub fn new() -> AuthUserGetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserGetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGetRequest {
        AuthUserGetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthUserGetRequest| { &m.name },
                |m: &mut AuthUserGetRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserGetRequest>(
                "AuthUserGetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserGetRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUserGetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserGetRequest::new)
    }
}

impl ::protobuf::Clear for AuthUserGetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserDeleteRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserDeleteRequest {
    fn default() -> &'a AuthUserDeleteRequest {
        <AuthUserDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserDeleteRequest {
    pub fn new() -> AuthUserDeleteRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserDeleteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserDeleteRequest {
        AuthUserDeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthUserDeleteRequest| { &m.name },
                |m: &mut AuthUserDeleteRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserDeleteRequest>(
                "AuthUserDeleteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserDeleteRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUserDeleteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserDeleteRequest::new)
    }
}

impl ::protobuf::Clear for AuthUserDeleteRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserDeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserChangePasswordRequest {
    // message fields
    pub name: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserChangePasswordRequest {
    fn default() -> &'a AuthUserChangePasswordRequest {
        <AuthUserChangePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserChangePasswordRequest {
    pub fn new() -> AuthUserChangePasswordRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserChangePasswordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserChangePasswordRequest {
        AuthUserChangePasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthUserChangePasswordRequest| { &m.name },
                |m: &mut AuthUserChangePasswordRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &AuthUserChangePasswordRequest| { &m.password },
                |m: &mut AuthUserChangePasswordRequest| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserChangePasswordRequest>(
                "AuthUserChangePasswordRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserChangePasswordRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUserChangePasswordRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserChangePasswordRequest::new)
    }
}

impl ::protobuf::Clear for AuthUserChangePasswordRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserChangePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserChangePasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGrantRoleRequest {
    // message fields
    pub user: ::std::string::String,
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGrantRoleRequest {
    fn default() -> &'a AuthUserGrantRoleRequest {
        <AuthUserGrantRoleRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGrantRoleRequest {
    pub fn new() -> AuthUserGrantRoleRequest {
        ::std::default::Default::default()
    }

    // string user = 1;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // string role = 2;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserGrantRoleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user);
        }
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user.is_empty() {
            os.write_string(1, &self.user)?;
        }
        if !self.role.is_empty() {
            os.write_string(2, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGrantRoleRequest {
        AuthUserGrantRoleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &AuthUserGrantRoleRequest| { &m.user },
                |m: &mut AuthUserGrantRoleRequest| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &AuthUserGrantRoleRequest| { &m.role },
                |m: &mut AuthUserGrantRoleRequest| { &mut m.role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserGrantRoleRequest>(
                "AuthUserGrantRoleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserGrantRoleRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUserGrantRoleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserGrantRoleRequest::new)
    }
}

impl ::protobuf::Clear for AuthUserGrantRoleRequest {
    fn clear(&mut self) {
        self.user.clear();
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGrantRoleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGrantRoleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserRevokeRoleRequest {
    // message fields
    pub name: ::std::string::String,
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserRevokeRoleRequest {
    fn default() -> &'a AuthUserRevokeRoleRequest {
        <AuthUserRevokeRoleRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserRevokeRoleRequest {
    pub fn new() -> AuthUserRevokeRoleRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string role = 2;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUserRevokeRoleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.role.is_empty() {
            os.write_string(2, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserRevokeRoleRequest {
        AuthUserRevokeRoleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthUserRevokeRoleRequest| { &m.name },
                |m: &mut AuthUserRevokeRoleRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &AuthUserRevokeRoleRequest| { &m.role },
                |m: &mut AuthUserRevokeRoleRequest| { &mut m.role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserRevokeRoleRequest>(
                "AuthUserRevokeRoleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserRevokeRoleRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUserRevokeRoleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserRevokeRoleRequest::new)
    }
}

impl ::protobuf::Clear for AuthUserRevokeRoleRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserRevokeRoleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserRevokeRoleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleAddRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleAddRequest {
    fn default() -> &'a AuthRoleAddRequest {
        <AuthRoleAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleAddRequest {
    pub fn new() -> AuthRoleAddRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleAddRequest {
        AuthRoleAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthRoleAddRequest| { &m.name },
                |m: &mut AuthRoleAddRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleAddRequest>(
                "AuthRoleAddRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleAddRequest {
        static instance: ::protobuf::rt::LazyV2<AuthRoleAddRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleAddRequest::new)
    }
}

impl ::protobuf::Clear for AuthRoleAddRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGetRequest {
    // message fields
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGetRequest {
    fn default() -> &'a AuthRoleGetRequest {
        <AuthRoleGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGetRequest {
    pub fn new() -> AuthRoleGetRequest {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleGetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGetRequest {
        AuthRoleGetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &AuthRoleGetRequest| { &m.role },
                |m: &mut AuthRoleGetRequest| { &mut m.role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleGetRequest>(
                "AuthRoleGetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleGetRequest {
        static instance: ::protobuf::rt::LazyV2<AuthRoleGetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleGetRequest::new)
    }
}

impl ::protobuf::Clear for AuthRoleGetRequest {
    fn clear(&mut self) {
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserListRequest {
    fn default() -> &'a AuthUserListRequest {
        <AuthUserListRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserListRequest {
    pub fn new() -> AuthUserListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthUserListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserListRequest {
        AuthUserListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserListRequest>(
                "AuthUserListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserListRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUserListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserListRequest::new)
    }
}

impl ::protobuf::Clear for AuthUserListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleListRequest {
    fn default() -> &'a AuthRoleListRequest {
        <AuthRoleListRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleListRequest {
    pub fn new() -> AuthRoleListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthRoleListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleListRequest {
        AuthRoleListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleListRequest>(
                "AuthRoleListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleListRequest {
        static instance: ::protobuf::rt::LazyV2<AuthRoleListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleListRequest::new)
    }
}

impl ::protobuf::Clear for AuthRoleListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleDeleteRequest {
    // message fields
    pub role: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleDeleteRequest {
    fn default() -> &'a AuthRoleDeleteRequest {
        <AuthRoleDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleDeleteRequest {
    pub fn new() -> AuthRoleDeleteRequest {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleDeleteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleDeleteRequest {
        AuthRoleDeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &AuthRoleDeleteRequest| { &m.role },
                |m: &mut AuthRoleDeleteRequest| { &mut m.role },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleDeleteRequest>(
                "AuthRoleDeleteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleDeleteRequest {
        static instance: ::protobuf::rt::LazyV2<AuthRoleDeleteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleDeleteRequest::new)
    }
}

impl ::protobuf::Clear for AuthRoleDeleteRequest {
    fn clear(&mut self) {
        self.role.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleDeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGrantPermissionRequest {
    // message fields
    pub name: ::std::string::String,
    pub perm: ::protobuf::SingularPtrField<super::auth::Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGrantPermissionRequest {
    fn default() -> &'a AuthRoleGrantPermissionRequest {
        <AuthRoleGrantPermissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGrantPermissionRequest {
    pub fn new() -> AuthRoleGrantPermissionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .authpb.Permission perm = 2;


    pub fn get_perm(&self) -> &super::auth::Permission {
        self.perm.as_ref().unwrap_or_else(|| <super::auth::Permission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_perm(&mut self) {
        self.perm.clear();
    }

    pub fn has_perm(&self) -> bool {
        self.perm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: super::auth::Permission) {
        self.perm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perm(&mut self) -> &mut super::auth::Permission {
        if self.perm.is_none() {
            self.perm.set_default();
        }
        self.perm.as_mut().unwrap()
    }

    // Take field
    pub fn take_perm(&mut self) -> super::auth::Permission {
        self.perm.take().unwrap_or_else(|| super::auth::Permission::new())
    }
}

impl ::protobuf::Message for AuthRoleGrantPermissionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.perm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.perm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.perm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.perm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGrantPermissionRequest {
        AuthRoleGrantPermissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AuthRoleGrantPermissionRequest| { &m.name },
                |m: &mut AuthRoleGrantPermissionRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::auth::Permission>>(
                "perm",
                |m: &AuthRoleGrantPermissionRequest| { &m.perm },
                |m: &mut AuthRoleGrantPermissionRequest| { &mut m.perm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleGrantPermissionRequest>(
                "AuthRoleGrantPermissionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleGrantPermissionRequest {
        static instance: ::protobuf::rt::LazyV2<AuthRoleGrantPermissionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleGrantPermissionRequest::new)
    }
}

impl ::protobuf::Clear for AuthRoleGrantPermissionRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.perm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGrantPermissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGrantPermissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleRevokePermissionRequest {
    // message fields
    pub role: ::std::string::String,
    pub key: ::std::string::String,
    pub range_end: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleRevokePermissionRequest {
    fn default() -> &'a AuthRoleRevokePermissionRequest {
        <AuthRoleRevokePermissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleRevokePermissionRequest {
    pub fn new() -> AuthRoleRevokePermissionRequest {
        ::std::default::Default::default()
    }

    // string role = 1;


    pub fn get_role(&self) -> &str {
        &self.role
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        &mut self.role
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.role, ::std::string::String::new())
    }

    // string key = 2;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string range_end = 3;


    pub fn get_range_end(&self) -> &str {
        &self.range_end
    }
    pub fn clear_range_end(&mut self) {
        self.range_end.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: ::std::string::String) {
        self.range_end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_end(&mut self) -> &mut ::std::string::String {
        &mut self.range_end
    }

    // Take field
    pub fn take_range_end(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.range_end, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRoleRevokePermissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.role)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.range_end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.role.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.role);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.range_end.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.range_end);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.role.is_empty() {
            os.write_string(1, &self.role)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.range_end.is_empty() {
            os.write_string(3, &self.range_end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleRevokePermissionRequest {
        AuthRoleRevokePermissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &AuthRoleRevokePermissionRequest| { &m.role },
                |m: &mut AuthRoleRevokePermissionRequest| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &AuthRoleRevokePermissionRequest| { &m.key },
                |m: &mut AuthRoleRevokePermissionRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "range_end",
                |m: &AuthRoleRevokePermissionRequest| { &m.range_end },
                |m: &mut AuthRoleRevokePermissionRequest| { &mut m.range_end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleRevokePermissionRequest>(
                "AuthRoleRevokePermissionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleRevokePermissionRequest {
        static instance: ::protobuf::rt::LazyV2<AuthRoleRevokePermissionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleRevokePermissionRequest::new)
    }
}

impl ::protobuf::Clear for AuthRoleRevokePermissionRequest {
    fn clear(&mut self) {
        self.role.clear();
        self.key.clear();
        self.range_end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleRevokePermissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleRevokePermissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthEnableResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthEnableResponse {
    fn default() -> &'a AuthEnableResponse {
        <AuthEnableResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthEnableResponse {
    pub fn new() -> AuthEnableResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthEnableResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthEnableResponse {
        AuthEnableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthEnableResponse| { &m.header },
                |m: &mut AuthEnableResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthEnableResponse>(
                "AuthEnableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthEnableResponse {
        static instance: ::protobuf::rt::LazyV2<AuthEnableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthEnableResponse::new)
    }
}

impl ::protobuf::Clear for AuthEnableResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthEnableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthEnableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthDisableResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthDisableResponse {
    fn default() -> &'a AuthDisableResponse {
        <AuthDisableResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthDisableResponse {
    pub fn new() -> AuthDisableResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthDisableResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthDisableResponse {
        AuthDisableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthDisableResponse| { &m.header },
                |m: &mut AuthDisableResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthDisableResponse>(
                "AuthDisableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthDisableResponse {
        static instance: ::protobuf::rt::LazyV2<AuthDisableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthDisableResponse::new)
    }
}

impl ::protobuf::Clear for AuthDisableResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthDisableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthDisableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticateResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateResponse {
    fn default() -> &'a AuthenticateResponse {
        <AuthenticateResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateResponse {
    pub fn new() -> AuthenticateResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // string token = 2;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthenticateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.token.is_empty() {
            os.write_string(2, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateResponse {
        AuthenticateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthenticateResponse| { &m.header },
                |m: &mut AuthenticateResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &AuthenticateResponse| { &m.token },
                |m: &mut AuthenticateResponse| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticateResponse>(
                "AuthenticateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticateResponse {
        static instance: ::protobuf::rt::LazyV2<AuthenticateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticateResponse::new)
    }
}

impl ::protobuf::Clear for AuthenticateResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserAddResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserAddResponse {
    fn default() -> &'a AuthUserAddResponse {
        <AuthUserAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserAddResponse {
    pub fn new() -> AuthUserAddResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserAddResponse {
        AuthUserAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthUserAddResponse| { &m.header },
                |m: &mut AuthUserAddResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserAddResponse>(
                "AuthUserAddResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserAddResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUserAddResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserAddResponse::new)
    }
}

impl ::protobuf::Clear for AuthUserAddResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGetResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub roles: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGetResponse {
    fn default() -> &'a AuthUserGetResponse {
        <AuthUserGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGetResponse {
    pub fn new() -> AuthUserGetResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated string roles = 2;


    pub fn get_roles(&self) -> &[::std::string::String] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthUserGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.roles {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.roles {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGetResponse {
        AuthUserGetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthUserGetResponse| { &m.header },
                |m: &mut AuthUserGetResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "roles",
                |m: &AuthUserGetResponse| { &m.roles },
                |m: &mut AuthUserGetResponse| { &mut m.roles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserGetResponse>(
                "AuthUserGetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserGetResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUserGetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserGetResponse::new)
    }
}

impl ::protobuf::Clear for AuthUserGetResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserDeleteResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserDeleteResponse {
    fn default() -> &'a AuthUserDeleteResponse {
        <AuthUserDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserDeleteResponse {
    pub fn new() -> AuthUserDeleteResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserDeleteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserDeleteResponse {
        AuthUserDeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthUserDeleteResponse| { &m.header },
                |m: &mut AuthUserDeleteResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserDeleteResponse>(
                "AuthUserDeleteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserDeleteResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUserDeleteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserDeleteResponse::new)
    }
}

impl ::protobuf::Clear for AuthUserDeleteResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserDeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserChangePasswordResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserChangePasswordResponse {
    fn default() -> &'a AuthUserChangePasswordResponse {
        <AuthUserChangePasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserChangePasswordResponse {
    pub fn new() -> AuthUserChangePasswordResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserChangePasswordResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserChangePasswordResponse {
        AuthUserChangePasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthUserChangePasswordResponse| { &m.header },
                |m: &mut AuthUserChangePasswordResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserChangePasswordResponse>(
                "AuthUserChangePasswordResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserChangePasswordResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUserChangePasswordResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserChangePasswordResponse::new)
    }
}

impl ::protobuf::Clear for AuthUserChangePasswordResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserChangePasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserChangePasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserGrantRoleResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserGrantRoleResponse {
    fn default() -> &'a AuthUserGrantRoleResponse {
        <AuthUserGrantRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserGrantRoleResponse {
    pub fn new() -> AuthUserGrantRoleResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserGrantRoleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserGrantRoleResponse {
        AuthUserGrantRoleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthUserGrantRoleResponse| { &m.header },
                |m: &mut AuthUserGrantRoleResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserGrantRoleResponse>(
                "AuthUserGrantRoleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserGrantRoleResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUserGrantRoleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserGrantRoleResponse::new)
    }
}

impl ::protobuf::Clear for AuthUserGrantRoleResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserGrantRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserGrantRoleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserRevokeRoleResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserRevokeRoleResponse {
    fn default() -> &'a AuthUserRevokeRoleResponse {
        <AuthUserRevokeRoleResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserRevokeRoleResponse {
    pub fn new() -> AuthUserRevokeRoleResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthUserRevokeRoleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserRevokeRoleResponse {
        AuthUserRevokeRoleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthUserRevokeRoleResponse| { &m.header },
                |m: &mut AuthUserRevokeRoleResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserRevokeRoleResponse>(
                "AuthUserRevokeRoleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserRevokeRoleResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUserRevokeRoleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserRevokeRoleResponse::new)
    }
}

impl ::protobuf::Clear for AuthUserRevokeRoleResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserRevokeRoleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserRevokeRoleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleAddResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleAddResponse {
    fn default() -> &'a AuthRoleAddResponse {
        <AuthRoleAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleAddResponse {
    pub fn new() -> AuthRoleAddResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleAddResponse {
        AuthRoleAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthRoleAddResponse| { &m.header },
                |m: &mut AuthRoleAddResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleAddResponse>(
                "AuthRoleAddResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleAddResponse {
        static instance: ::protobuf::rt::LazyV2<AuthRoleAddResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleAddResponse::new)
    }
}

impl ::protobuf::Clear for AuthRoleAddResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGetResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub perm: ::protobuf::RepeatedField<super::auth::Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGetResponse {
    fn default() -> &'a AuthRoleGetResponse {
        <AuthRoleGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGetResponse {
    pub fn new() -> AuthRoleGetResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated .authpb.Permission perm = 2;


    pub fn get_perm(&self) -> &[super::auth::Permission] {
        &self.perm
    }
    pub fn clear_perm(&mut self) {
        self.perm.clear();
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: ::protobuf::RepeatedField<super::auth::Permission>) {
        self.perm = v;
    }

    // Mutable pointer to the field.
    pub fn mut_perm(&mut self) -> &mut ::protobuf::RepeatedField<super::auth::Permission> {
        &mut self.perm
    }

    // Take field
    pub fn take_perm(&mut self) -> ::protobuf::RepeatedField<super::auth::Permission> {
        ::std::mem::replace(&mut self.perm, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthRoleGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.perm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.perm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.perm {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.perm {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGetResponse {
        AuthRoleGetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthRoleGetResponse| { &m.header },
                |m: &mut AuthRoleGetResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::auth::Permission>>(
                "perm",
                |m: &AuthRoleGetResponse| { &m.perm },
                |m: &mut AuthRoleGetResponse| { &mut m.perm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleGetResponse>(
                "AuthRoleGetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleGetResponse {
        static instance: ::protobuf::rt::LazyV2<AuthRoleGetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleGetResponse::new)
    }
}

impl ::protobuf::Clear for AuthRoleGetResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.perm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleListResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub roles: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleListResponse {
    fn default() -> &'a AuthRoleListResponse {
        <AuthRoleListResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleListResponse {
    pub fn new() -> AuthRoleListResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated string roles = 2;


    pub fn get_roles(&self) -> &[::std::string::String] {
        &self.roles
    }
    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.roles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthRoleListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.roles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.roles {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.roles {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleListResponse {
        AuthRoleListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthRoleListResponse| { &m.header },
                |m: &mut AuthRoleListResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "roles",
                |m: &AuthRoleListResponse| { &m.roles },
                |m: &mut AuthRoleListResponse| { &mut m.roles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleListResponse>(
                "AuthRoleListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleListResponse {
        static instance: ::protobuf::rt::LazyV2<AuthRoleListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleListResponse::new)
    }
}

impl ::protobuf::Clear for AuthRoleListResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.roles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUserListResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    pub users: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUserListResponse {
    fn default() -> &'a AuthUserListResponse {
        <AuthUserListResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUserListResponse {
    pub fn new() -> AuthUserListResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }

    // repeated string users = 2;


    pub fn get_users(&self) -> &[::std::string::String] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthUserListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.users {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.users {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUserListResponse {
        AuthUserListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthUserListResponse| { &m.header },
                |m: &mut AuthUserListResponse| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "users",
                |m: &AuthUserListResponse| { &m.users },
                |m: &mut AuthUserListResponse| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUserListResponse>(
                "AuthUserListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUserListResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUserListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUserListResponse::new)
    }
}

impl ::protobuf::Clear for AuthUserListResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUserListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUserListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleDeleteResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleDeleteResponse {
    fn default() -> &'a AuthRoleDeleteResponse {
        <AuthRoleDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleDeleteResponse {
    pub fn new() -> AuthRoleDeleteResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleDeleteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleDeleteResponse {
        AuthRoleDeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthRoleDeleteResponse| { &m.header },
                |m: &mut AuthRoleDeleteResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleDeleteResponse>(
                "AuthRoleDeleteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleDeleteResponse {
        static instance: ::protobuf::rt::LazyV2<AuthRoleDeleteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleDeleteResponse::new)
    }
}

impl ::protobuf::Clear for AuthRoleDeleteResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleDeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleGrantPermissionResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleGrantPermissionResponse {
    fn default() -> &'a AuthRoleGrantPermissionResponse {
        <AuthRoleGrantPermissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleGrantPermissionResponse {
    pub fn new() -> AuthRoleGrantPermissionResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleGrantPermissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleGrantPermissionResponse {
        AuthRoleGrantPermissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthRoleGrantPermissionResponse| { &m.header },
                |m: &mut AuthRoleGrantPermissionResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleGrantPermissionResponse>(
                "AuthRoleGrantPermissionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleGrantPermissionResponse {
        static instance: ::protobuf::rt::LazyV2<AuthRoleGrantPermissionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleGrantPermissionResponse::new)
    }
}

impl ::protobuf::Clear for AuthRoleGrantPermissionResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleGrantPermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleGrantPermissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRoleRevokePermissionResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<ResponseHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRoleRevokePermissionResponse {
    fn default() -> &'a AuthRoleRevokePermissionResponse {
        <AuthRoleRevokePermissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRoleRevokePermissionResponse {
    pub fn new() -> AuthRoleRevokePermissionResponse {
        ::std::default::Default::default()
    }

    // .etcdserverpb.ResponseHeader header = 1;


    pub fn get_header(&self) -> &ResponseHeader {
        self.header.as_ref().unwrap_or_else(|| <ResponseHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ResponseHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ResponseHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ResponseHeader {
        self.header.take().unwrap_or_else(|| ResponseHeader::new())
    }
}

impl ::protobuf::Message for AuthRoleRevokePermissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRoleRevokePermissionResponse {
        AuthRoleRevokePermissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResponseHeader>>(
                "header",
                |m: &AuthRoleRevokePermissionResponse| { &m.header },
                |m: &mut AuthRoleRevokePermissionResponse| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRoleRevokePermissionResponse>(
                "AuthRoleRevokePermissionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRoleRevokePermissionResponse {
        static instance: ::protobuf::rt::LazyV2<AuthRoleRevokePermissionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRoleRevokePermissionResponse::new)
    }
}

impl ::protobuf::Clear for AuthRoleRevokePermissionResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRoleRevokePermissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRoleRevokePermissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AlarmType {
    NONE = 0,
    NOSPACE = 1,
}

impl ::protobuf::ProtobufEnum for AlarmType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlarmType> {
        match value {
            0 => ::std::option::Option::Some(AlarmType::NONE),
            1 => ::std::option::Option::Some(AlarmType::NOSPACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AlarmType] = &[
            AlarmType::NONE,
            AlarmType::NOSPACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AlarmType>("AlarmType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AlarmType {
}

impl ::std::default::Default for AlarmType {
    fn default() -> Self {
        AlarmType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fproto/rpc.proto\x12\x0cetcdserverpb\x1a\x0eproto/kv.proto\x1a\x10p\
    roto/auth.proto\"\x85\x01\n\x0eResponseHeader\x12\x1d\n\ncluster_id\x18\
    \x01\x20\x01(\x04R\tclusterId\x12\x1b\n\tmember_id\x18\x02\x20\x01(\x04R\
    \x08memberId\x12\x1a\n\x08revision\x18\x03\x20\x01(\x03R\x08revision\x12\
    \x1b\n\traft_term\x18\x04\x20\x01(\x04R\x08raftTerm\"\x84\x05\n\x0cRange\
    Request\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x1b\n\trange_e\
    nd\x18\x02\x20\x01(\x0cR\x08rangeEnd\x12\x14\n\x05limit\x18\x03\x20\x01(\
    \x03R\x05limit\x12\x1a\n\x08revision\x18\x04\x20\x01(\x03R\x08revision\
    \x12C\n\nsort_order\x18\x05\x20\x01(\x0e2$.etcdserverpb.RangeRequest.Sor\
    tOrderR\tsortOrder\x12F\n\x0bsort_target\x18\x06\x20\x01(\x0e2%.etcdserv\
    erpb.RangeRequest.SortTargetR\nsortTarget\x12\"\n\x0cserializable\x18\
    \x07\x20\x01(\x08R\x0cserializable\x12\x1b\n\tkeys_only\x18\x08\x20\x01(\
    \x08R\x08keysOnly\x12\x1d\n\ncount_only\x18\t\x20\x01(\x08R\tcountOnly\
    \x12(\n\x10min_mod_revision\x18\n\x20\x01(\x03R\x0eminModRevision\x12(\n\
    \x10max_mod_revision\x18\x0b\x20\x01(\x03R\x0emaxModRevision\x12.\n\x13m\
    in_create_revision\x18\x0c\x20\x01(\x03R\x11minCreateRevision\x12.\n\x13\
    max_create_revision\x18\r\x20\x01(\x03R\x11maxCreateRevision\".\n\tSortO\
    rder\x12\x08\n\x04NONE\x10\0\x12\n\n\x06ASCEND\x10\x01\x12\x0b\n\x07DESC\
    END\x10\x02\"B\n\nSortTarget\x12\x07\n\x03KEY\x10\0\x12\x0b\n\x07VERSION\
    \x10\x01\x12\n\n\x06CREATE\x10\x02\x12\x07\n\x03MOD\x10\x03\x12\t\n\x05V\
    ALUE\x10\x04\"\x93\x01\n\rRangeResponse\x124\n\x06header\x18\x01\x20\x01\
    (\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\"\n\x03kvs\x18\x02\
    \x20\x03(\x0b2\x10.mvccpb.KeyValueR\x03kvs\x12\x12\n\x04more\x18\x03\x20\
    \x01(\x08R\x04more\x12\x14\n\x05count\x18\x04\x20\x01(\x03R\x05count\"\
    \xa9\x01\n\nPutRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\x12\x14\n\x05lease\x18\
    \x03\x20\x01(\x03R\x05lease\x12\x17\n\x07prev_kv\x18\x04\x20\x01(\x08R\
    \x06prevKv\x12!\n\x0cignore_value\x18\x05\x20\x01(\x08R\x0bignoreValue\
    \x12!\n\x0cignore_lease\x18\x06\x20\x01(\x08R\x0bignoreLease\"n\n\x0bPut\
    Response\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.Respons\
    eHeaderR\x06header\x12)\n\x07prev_kv\x18\x02\x20\x01(\x0b2\x10.mvccpb.Ke\
    yValueR\x06prevKv\"\\\n\x12DeleteRangeRequest\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x0cR\x03key\x12\x1b\n\trange_end\x18\x02\x20\x01(\x0cR\x08rang\
    eEnd\x12\x17\n\x07prev_kv\x18\x03\x20\x01(\x08R\x06prevKv\"\x92\x01\n\
    \x13DeleteRangeResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcds\
    erverpb.ResponseHeaderR\x06header\x12\x18\n\x07deleted\x18\x02\x20\x01(\
    \x03R\x07deleted\x12+\n\x08prev_kvs\x18\x03\x20\x03(\x0b2\x10.mvccpb.Key\
    ValueR\x07prevKvs\"\xa9\x02\n\tRequestOp\x12A\n\rrequest_range\x18\x01\
    \x20\x01(\x0b2\x1a.etcdserverpb.RangeRequestH\0R\x0crequestRange\x12;\n\
    \x0brequest_put\x18\x02\x20\x01(\x0b2\x18.etcdserverpb.PutRequestH\0R\nr\
    equestPut\x12T\n\x14request_delete_range\x18\x03\x20\x01(\x0b2\x20.etcds\
    erverpb.DeleteRangeRequestH\0R\x12requestDeleteRange\x12;\n\x0brequest_t\
    xn\x18\x04\x20\x01(\x0b2\x18.etcdserverpb.TxnRequestH\0R\nrequestTxnB\t\
    \n\x07request\"\xb7\x02\n\nResponseOp\x12D\n\x0eresponse_range\x18\x01\
    \x20\x01(\x0b2\x1b.etcdserverpb.RangeResponseH\0R\rresponseRange\x12>\n\
    \x0cresponse_put\x18\x02\x20\x01(\x0b2\x19.etcdserverpb.PutResponseH\0R\
    \x0bresponsePut\x12W\n\x15response_delete_range\x18\x03\x20\x01(\x0b2!.e\
    tcdserverpb.DeleteRangeResponseH\0R\x13responseDeleteRange\x12>\n\x0cres\
    ponse_txn\x18\x04\x20\x01(\x0b2\x19.etcdserverpb.TxnResponseH\0R\x0bresp\
    onseTxnB\n\n\x08response\"\xc6\x03\n\x07Compare\x12;\n\x06result\x18\x01\
    \x20\x01(\x0e2#.etcdserverpb.Compare.CompareResultR\x06result\x12;\n\x06\
    target\x18\x02\x20\x01(\x0e2#.etcdserverpb.Compare.CompareTargetR\x06tar\
    get\x12\x10\n\x03key\x18\x03\x20\x01(\x0cR\x03key\x12\x1a\n\x07version\
    \x18\x04\x20\x01(\x03H\0R\x07version\x12)\n\x0fcreate_revision\x18\x05\
    \x20\x01(\x03H\0R\x0ecreateRevision\x12#\n\x0cmod_revision\x18\x06\x20\
    \x01(\x03H\0R\x0bmodRevision\x12\x16\n\x05value\x18\x07\x20\x01(\x0cH\0R\
    \x05value\x12\x1b\n\trange_end\x18\x08\x20\x01(\x0cR\x08rangeEnd\"@\n\rC\
    ompareResult\x12\t\n\x05EQUAL\x10\0\x12\x0b\n\x07GREATER\x10\x01\x12\x08\
    \n\x04LESS\x10\x02\x12\r\n\tNOT_EQUAL\x10\x03\"<\n\rCompareTarget\x12\
    \x0b\n\x07VERSION\x10\0\x12\n\n\x06CREATE\x10\x01\x12\x07\n\x03MOD\x10\
    \x02\x12\t\n\x05VALUE\x10\x03B\x0e\n\x0ctarget_union\"\xa3\x01\n\nTxnReq\
    uest\x12/\n\x07compare\x18\x01\x20\x03(\x0b2\x15.etcdserverpb.CompareR\
    \x07compare\x121\n\x07success\x18\x02\x20\x03(\x0b2\x17.etcdserverpb.Req\
    uestOpR\x07success\x121\n\x07failure\x18\x03\x20\x03(\x0b2\x17.etcdserve\
    rpb.RequestOpR\x07failure\"\x99\x01\n\x0bTxnResponse\x124\n\x06header\
    \x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\
    \x1c\n\tsucceeded\x18\x02\x20\x01(\x08R\tsucceeded\x126\n\tresponses\x18\
    \x03\x20\x03(\x0b2\x18.etcdserverpb.ResponseOpR\tresponses\"K\n\x11Compa\
    ctionRequest\x12\x1a\n\x08revision\x18\x01\x20\x01(\x03R\x08revision\x12\
    \x1a\n\x08physical\x18\x02\x20\x01(\x08R\x08physical\"J\n\x12CompactionR\
    esponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.Response\
    HeaderR\x06header\"\r\n\x0bHashRequest\"X\n\x0cHashResponse\x124\n\x06he\
    ader\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\
    \x12\x12\n\x04hash\x18\x02\x20\x01(\rR\x04hash\"+\n\rHashKVRequest\x12\
    \x1a\n\x08revision\x18\x01\x20\x01(\x03R\x08revision\"\x85\x01\n\x0eHash\
    KVResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.Respo\
    nseHeaderR\x06header\x12\x12\n\x04hash\x18\x02\x20\x01(\rR\x04hash\x12)\
    \n\x10compact_revision\x18\x03\x20\x01(\x03R\x0fcompactRevision\"\x11\n\
    \x0fSnapshotRequest\"\x85\x01\n\x10SnapshotResponse\x124\n\x06header\x18\
    \x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12'\n\x0f\
    remaining_bytes\x18\x02\x20\x01(\x04R\x0eremainingBytes\x12\x12\n\x04blo\
    b\x18\x03\x20\x01(\x0cR\x04blob\"\xb5\x01\n\x0cWatchRequest\x12I\n\x0ecr\
    eate_request\x18\x01\x20\x01(\x0b2\x20.etcdserverpb.WatchCreateRequestH\
    \0R\rcreateRequest\x12I\n\x0ecancel_request\x18\x02\x20\x01(\x0b2\x20.et\
    cdserverpb.WatchCancelRequestH\0R\rcancelRequestB\x0f\n\rrequest_union\"\
    \x9a\x02\n\x12WatchCreateRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\
    \x03key\x12\x1b\n\trange_end\x18\x02\x20\x01(\x0cR\x08rangeEnd\x12%\n\
    \x0estart_revision\x18\x03\x20\x01(\x03R\rstartRevision\x12'\n\x0fprogre\
    ss_notify\x18\x04\x20\x01(\x08R\x0eprogressNotify\x12E\n\x07filters\x18\
    \x05\x20\x03(\x0e2+.etcdserverpb.WatchCreateRequest.FilterTypeR\x07filte\
    rs\x12\x17\n\x07prev_kv\x18\x06\x20\x01(\x08R\x06prevKv\"%\n\nFilterType\
    \x12\t\n\x05NOPUT\x10\0\x12\x0c\n\x08NODELETE\x10\x01\"/\n\x12WatchCance\
    lRequest\x12\x19\n\x08watch_id\x18\x01\x20\x01(\x03R\x07watchId\"\x8d\
    \x02\n\rWatchResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdser\
    verpb.ResponseHeaderR\x06header\x12\x19\n\x08watch_id\x18\x02\x20\x01(\
    \x03R\x07watchId\x12\x18\n\x07created\x18\x03\x20\x01(\x08R\x07created\
    \x12\x1a\n\x08canceled\x18\x04\x20\x01(\x08R\x08canceled\x12)\n\x10compa\
    ct_revision\x18\x05\x20\x01(\x03R\x0fcompactRevision\x12#\n\rcancel_reas\
    on\x18\x06\x20\x01(\tR\x0ccancelReason\x12%\n\x06events\x18\x0b\x20\x03(\
    \x0b2\r.mvccpb.EventR\x06events\"5\n\x11LeaseGrantRequest\x12\x10\n\x03T\
    TL\x18\x01\x20\x01(\x03R\x03TTL\x12\x0e\n\x02ID\x18\x02\x20\x01(\x03R\
    \x02ID\"\x82\x01\n\x12LeaseGrantResponse\x124\n\x06header\x18\x01\x20\
    \x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\x0e\n\x02ID\
    \x18\x02\x20\x01(\x03R\x02ID\x12\x10\n\x03TTL\x18\x03\x20\x01(\x03R\x03T\
    TL\x12\x14\n\x05error\x18\x04\x20\x01(\tR\x05error\"$\n\x12LeaseRevokeRe\
    quest\x12\x0e\n\x02ID\x18\x01\x20\x01(\x03R\x02ID\"K\n\x13LeaseRevokeRes\
    ponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHe\
    aderR\x06header\"'\n\x15LeaseKeepAliveRequest\x12\x0e\n\x02ID\x18\x01\
    \x20\x01(\x03R\x02ID\"p\n\x16LeaseKeepAliveResponse\x124\n\x06header\x18\
    \x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\x0e\n\
    \x02ID\x18\x02\x20\x01(\x03R\x02ID\x12\x10\n\x03TTL\x18\x03\x20\x01(\x03\
    R\x03TTL\"<\n\x16LeaseTimeToLiveRequest\x12\x0e\n\x02ID\x18\x01\x20\x01(\
    \x03R\x02ID\x12\x12\n\x04keys\x18\x02\x20\x01(\x08R\x04keys\"\xa5\x01\n\
    \x17LeaseTimeToLiveResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.e\
    tcdserverpb.ResponseHeaderR\x06header\x12\x0e\n\x02ID\x18\x02\x20\x01(\
    \x03R\x02ID\x12\x10\n\x03TTL\x18\x03\x20\x01(\x03R\x03TTL\x12\x1e\n\ngra\
    ntedTTL\x18\x04\x20\x01(\x03R\ngrantedTTL\x12\x12\n\x04keys\x18\x05\x20\
    \x03(\x0cR\x04keys\"h\n\x06Member\x12\x0e\n\x02ID\x18\x01\x20\x01(\x04R\
    \x02ID\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1a\n\x08peerUR\
    Ls\x18\x03\x20\x03(\tR\x08peerURLs\x12\x1e\n\nclientURLs\x18\x04\x20\x03\
    (\tR\nclientURLs\".\n\x10MemberAddRequest\x12\x1a\n\x08peerURLs\x18\x01\
    \x20\x03(\tR\x08peerURLs\"\xa7\x01\n\x11MemberAddResponse\x124\n\x06head\
    er\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12,\
    \n\x06member\x18\x02\x20\x01(\x0b2\x14.etcdserverpb.MemberR\x06member\
    \x12.\n\x07members\x18\x03\x20\x03(\x0b2\x14.etcdserverpb.MemberR\x07mem\
    bers\"%\n\x13MemberRemoveRequest\x12\x0e\n\x02ID\x18\x01\x20\x01(\x04R\
    \x02ID\"|\n\x14MemberRemoveResponse\x124\n\x06header\x18\x01\x20\x01(\
    \x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12.\n\x07members\x18\
    \x02\x20\x03(\x0b2\x14.etcdserverpb.MemberR\x07members\"A\n\x13MemberUpd\
    ateRequest\x12\x0e\n\x02ID\x18\x01\x20\x01(\x04R\x02ID\x12\x1a\n\x08peer\
    URLs\x18\x02\x20\x03(\tR\x08peerURLs\"|\n\x14MemberUpdateResponse\x124\n\
    \x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06hea\
    der\x12.\n\x07members\x18\x02\x20\x03(\x0b2\x14.etcdserverpb.MemberR\x07\
    members\"\x13\n\x11MemberListRequest\"z\n\x12MemberListResponse\x124\n\
    \x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06hea\
    der\x12.\n\x07members\x18\x02\x20\x03(\x0b2\x14.etcdserverpb.MemberR\x07\
    members\"\x13\n\x11DefragmentRequest\"J\n\x12DefragmentResponse\x124\n\
    \x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06hea\
    der\"/\n\x11MoveLeaderRequest\x12\x1a\n\x08targetID\x18\x01\x20\x01(\x04\
    R\x08targetID\"J\n\x12MoveLeaderResponse\x124\n\x06header\x18\x01\x20\
    \x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"\xcf\x01\n\x0cAla\
    rmRequest\x12>\n\x06action\x18\x01\x20\x01(\x0e2&.etcdserverpb.AlarmRequ\
    est.AlarmActionR\x06action\x12\x1a\n\x08memberID\x18\x02\x20\x01(\x04R\
    \x08memberID\x12-\n\x05alarm\x18\x03\x20\x01(\x0e2\x17.etcdserverpb.Alar\
    mTypeR\x05alarm\"4\n\x0bAlarmAction\x12\x07\n\x03GET\x10\0\x12\x0c\n\x08\
    ACTIVATE\x10\x01\x12\x0e\n\nDEACTIVATE\x10\x02\"X\n\x0bAlarmMember\x12\
    \x1a\n\x08memberID\x18\x01\x20\x01(\x04R\x08memberID\x12-\n\x05alarm\x18\
    \x02\x20\x01(\x0e2\x17.etcdserverpb.AlarmTypeR\x05alarm\"x\n\rAlarmRespo\
    nse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHead\
    erR\x06header\x121\n\x06alarms\x18\x02\x20\x03(\x0b2\x19.etcdserverpb.Al\
    armMemberR\x06alarms\"\x0f\n\rStatusRequest\"\xca\x01\n\x0eStatusRespons\
    e\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeader\
    R\x06header\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\x12\x16\
    \n\x06dbSize\x18\x03\x20\x01(\x03R\x06dbSize\x12\x16\n\x06leader\x18\x04\
    \x20\x01(\x04R\x06leader\x12\x1c\n\traftIndex\x18\x05\x20\x01(\x04R\traf\
    tIndex\x12\x1a\n\x08raftTerm\x18\x06\x20\x01(\x04R\x08raftTerm\"\x13\n\
    \x11AuthEnableRequest\"\x14\n\x12AuthDisableRequest\"E\n\x13Authenticate\
    Request\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08passw\
    ord\x18\x02\x20\x01(\tR\x08password\"D\n\x12AuthUserAddRequest\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08password\x18\x02\x20\
    \x01(\tR\x08password\"(\n\x12AuthUserGetRequest\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"+\n\x15AuthUserDeleteRequest\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\"O\n\x1dAuthUserChangePasswordRequest\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08password\x18\x02\
    \x20\x01(\tR\x08password\"B\n\x18AuthUserGrantRoleRequest\x12\x12\n\x04u\
    ser\x18\x01\x20\x01(\tR\x04user\x12\x12\n\x04role\x18\x02\x20\x01(\tR\
    \x04role\"C\n\x19AuthUserRevokeRoleRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x12\n\x04role\x18\x02\x20\x01(\tR\x04role\"(\n\x12A\
    uthRoleAddRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"(\n\x12\
    AuthRoleGetRequest\x12\x12\n\x04role\x18\x01\x20\x01(\tR\x04role\"\x15\n\
    \x13AuthUserListRequest\"\x15\n\x13AuthRoleListRequest\"+\n\x15AuthRoleD\
    eleteRequest\x12\x12\n\x04role\x18\x01\x20\x01(\tR\x04role\"\\\n\x1eAuth\
    RoleGrantPermissionRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12&\n\x04perm\x18\x02\x20\x01(\x0b2\x12.authpb.PermissionR\x04perm\"d\
    \n\x1fAuthRoleRevokePermissionRequest\x12\x12\n\x04role\x18\x01\x20\x01(\
    \tR\x04role\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x1b\n\trange\
    _end\x18\x03\x20\x01(\tR\x08rangeEnd\"J\n\x12AuthEnableResponse\x124\n\
    \x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06hea\
    der\"K\n\x13AuthDisableResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\
    \x1c.etcdserverpb.ResponseHeaderR\x06header\"b\n\x14AuthenticateResponse\
    \x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\
    \x06header\x12\x14\n\x05token\x18\x02\x20\x01(\tR\x05token\"K\n\x13AuthU\
    serAddResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.R\
    esponseHeaderR\x06header\"a\n\x13AuthUserGetResponse\x124\n\x06header\
    \x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\
    \x14\n\x05roles\x18\x02\x20\x03(\tR\x05roles\"N\n\x16AuthUserDeleteRespo\
    nse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHead\
    erR\x06header\"V\n\x1eAuthUserChangePasswordResponse\x124\n\x06header\
    \x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"Q\n\
    \x19AuthUserGrantRoleResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c\
    .etcdserverpb.ResponseHeaderR\x06header\"R\n\x1aAuthUserRevokeRoleRespon\
    se\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeade\
    rR\x06header\"K\n\x13AuthRoleAddResponse\x124\n\x06header\x18\x01\x20\
    \x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"s\n\x13AuthRoleGe\
    tResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.Respon\
    seHeaderR\x06header\x12&\n\x04perm\x18\x02\x20\x03(\x0b2\x12.authpb.Perm\
    issionR\x04perm\"b\n\x14AuthRoleListResponse\x124\n\x06header\x18\x01\
    \x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\x12\x14\n\x05r\
    oles\x18\x02\x20\x03(\tR\x05roles\"b\n\x14AuthUserListResponse\x124\n\
    \x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06hea\
    der\x12\x14\n\x05users\x18\x02\x20\x03(\tR\x05users\"N\n\x16AuthRoleDele\
    teResponse\x124\n\x06header\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.Respo\
    nseHeaderR\x06header\"W\n\x1fAuthRoleGrantPermissionResponse\x124\n\x06h\
    eader\x18\x01\x20\x01(\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header\"\
    X\n\x20AuthRoleRevokePermissionResponse\x124\n\x06header\x18\x01\x20\x01\
    (\x0b2\x1c.etcdserverpb.ResponseHeaderR\x06header*\"\n\tAlarmType\x12\
    \x08\n\x04NONE\x10\0\x12\x0b\n\x07NOSPACE\x10\x012\xea\x02\n\x02KV\x12B\
    \n\x05Range\x12\x1a.etcdserverpb.RangeRequest\x1a\x1b.etcdserverpb.Range\
    Response\"\0\x12<\n\x03Put\x12\x18.etcdserverpb.PutRequest\x1a\x19.etcds\
    erverpb.PutResponse\"\0\x12T\n\x0bDeleteRange\x12\x20.etcdserverpb.Delet\
    eRangeRequest\x1a!.etcdserverpb.DeleteRangeResponse\"\0\x12<\n\x03Txn\
    \x12\x18.etcdserverpb.TxnRequest\x1a\x19.etcdserverpb.TxnResponse\"\0\
    \x12N\n\x07Compact\x12\x1f.etcdserverpb.CompactionRequest\x1a\x20.etcdse\
    rverpb.CompactionResponse\"\02O\n\x05Watch\x12F\n\x05Watch\x12\x1a.etcds\
    erverpb.WatchRequest\x1a\x1b.etcdserverpb.WatchResponse\"\0(\x010\x012\
    \xf5\x02\n\x05Lease\x12Q\n\nLeaseGrant\x12\x1f.etcdserverpb.LeaseGrantRe\
    quest\x1a\x20.etcdserverpb.LeaseGrantResponse\"\0\x12T\n\x0bLeaseRevoke\
    \x12\x20.etcdserverpb.LeaseRevokeRequest\x1a!.etcdserverpb.LeaseRevokeRe\
    sponse\"\0\x12a\n\x0eLeaseKeepAlive\x12#.etcdserverpb.LeaseKeepAliveRequ\
    est\x1a$.etcdserverpb.LeaseKeepAliveResponse\"\0(\x010\x01\x12`\n\x0fLea\
    seTimeToLive\x12$.etcdserverpb.LeaseTimeToLiveRequest\x1a%.etcdserverpb.\
    LeaseTimeToLiveResponse\"\02\xde\x02\n\x07Cluster\x12N\n\tMemberAdd\x12\
    \x1e.etcdserverpb.MemberAddRequest\x1a\x1f.etcdserverpb.MemberAddRespons\
    e\"\0\x12W\n\x0cMemberRemove\x12!.etcdserverpb.MemberRemoveRequest\x1a\"\
    .etcdserverpb.MemberRemoveResponse\"\0\x12W\n\x0cMemberUpdate\x12!.etcds\
    erverpb.MemberUpdateRequest\x1a\".etcdserverpb.MemberUpdateResponse\"\0\
    \x12Q\n\nMemberList\x12\x1f.etcdserverpb.MemberListRequest\x1a\x20.etcds\
    erverpb.MemberListResponse\"\02\x95\x04\n\x0bMaintenance\x12B\n\x05Alarm\
    \x12\x1a.etcdserverpb.AlarmRequest\x1a\x1b.etcdserverpb.AlarmResponse\"\
    \0\x12E\n\x06Status\x12\x1b.etcdserverpb.StatusRequest\x1a\x1c.etcdserve\
    rpb.StatusResponse\"\0\x12Q\n\nDefragment\x12\x1f.etcdserverpb.Defragmen\
    tRequest\x1a\x20.etcdserverpb.DefragmentResponse\"\0\x12?\n\x04Hash\x12\
    \x19.etcdserverpb.HashRequest\x1a\x1a.etcdserverpb.HashResponse\"\0\x12E\
    \n\x06HashKV\x12\x1b.etcdserverpb.HashKVRequest\x1a\x1c.etcdserverpb.Has\
    hKVResponse\"\0\x12M\n\x08Snapshot\x12\x1d.etcdserverpb.SnapshotRequest\
    \x1a\x1e.etcdserverpb.SnapshotResponse\"\00\x01\x12Q\n\nMoveLeader\x12\
    \x1f.etcdserverpb.MoveLeaderRequest\x1a\x20.etcdserverpb.MoveLeaderRespo\
    nse\"\02\xdd\x0b\n\x04Auth\x12Q\n\nAuthEnable\x12\x1f.etcdserverpb.AuthE\
    nableRequest\x1a\x20.etcdserverpb.AuthEnableResponse\"\0\x12T\n\x0bAuthD\
    isable\x12\x20.etcdserverpb.AuthDisableRequest\x1a!.etcdserverpb.AuthDis\
    ableResponse\"\0\x12W\n\x0cAuthenticate\x12!.etcdserverpb.AuthenticateRe\
    quest\x1a\".etcdserverpb.AuthenticateResponse\"\0\x12P\n\x07UserAdd\x12\
    \x20.etcdserverpb.AuthUserAddRequest\x1a!.etcdserverpb.AuthUserAddRespon\
    se\"\0\x12P\n\x07UserGet\x12\x20.etcdserverpb.AuthUserGetRequest\x1a!.et\
    cdserverpb.AuthUserGetResponse\"\0\x12S\n\x08UserList\x12!.etcdserverpb.\
    AuthUserListRequest\x1a\".etcdserverpb.AuthUserListResponse\"\0\x12Y\n\n\
    UserDelete\x12#.etcdserverpb.AuthUserDeleteRequest\x1a$.etcdserverpb.Aut\
    hUserDeleteResponse\"\0\x12q\n\x12UserChangePassword\x12+.etcdserverpb.A\
    uthUserChangePasswordRequest\x1a,.etcdserverpb.AuthUserChangePasswordRes\
    ponse\"\0\x12b\n\rUserGrantRole\x12&.etcdserverpb.AuthUserGrantRoleReque\
    st\x1a'.etcdserverpb.AuthUserGrantRoleResponse\"\0\x12e\n\x0eUserRevokeR\
    ole\x12'.etcdserverpb.AuthUserRevokeRoleRequest\x1a(.etcdserverpb.AuthUs\
    erRevokeRoleResponse\"\0\x12P\n\x07RoleAdd\x12\x20.etcdserverpb.AuthRole\
    AddRequest\x1a!.etcdserverpb.AuthRoleAddResponse\"\0\x12P\n\x07RoleGet\
    \x12\x20.etcdserverpb.AuthRoleGetRequest\x1a!.etcdserverpb.AuthRoleGetRe\
    sponse\"\0\x12S\n\x08RoleList\x12!.etcdserverpb.AuthRoleListRequest\x1a\
    \".etcdserverpb.AuthRoleListResponse\"\0\x12Y\n\nRoleDelete\x12#.etcdser\
    verpb.AuthRoleDeleteRequest\x1a$.etcdserverpb.AuthRoleDeleteResponse\"\0\
    \x12t\n\x13RoleGrantPermission\x12,.etcdserverpb.AuthRoleGrantPermission\
    Request\x1a-.etcdserverpb.AuthRoleGrantPermissionResponse\"\0\x12w\n\x14\
    RoleRevokePermission\x12-.etcdserverpb.AuthRoleRevokePermissionRequest\
    \x1a..etcdserverpb.AuthRoleRevokePermissionResponse\"\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
